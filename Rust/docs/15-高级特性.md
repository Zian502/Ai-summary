# 高级特性

本章介绍 Rust 的高级特性，包括宏、unsafe Rust 和外部函数接口（FFI）。

## 宏（Macros）

宏是 Rust 的元编程工具，允许你编写生成代码的代码。

### 声明式宏（Declarative Macros）

使用 `macro_rules!` 定义声明式宏。

```rust
// 定义宏
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

fn main() {
    let v = vec![1, 2, 3];
    println!("{:?}", v);
}
```

### 过程宏（Procedural Macros）

过程宏更像是函数，接受代码作为输入，产生代码作为输出。

#### 自定义派生宏

```rust
// 需要创建单独的 crate
// Cargo.toml
// [lib]
// proc-macro = true

use proc_macro::TokenStream;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // 实现
}
```

#### 属性宏

```rust
#[route(GET, "/")]
fn index() {
    // ...
}
```

#### 函数式宏

```rust
#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    // 实现
}

// 使用
sql!(SELECT * FROM posts WHERE id = 1);
```

### 常用宏

```rust
fn main() {
    // println! - 打印到标准输出
    println!("Hello, world!");
    println!("数字: {}", 42);
    
    // format! - 格式化字符串
    let s = format!("Hello, {}!", "Rust");
    
    // panic! - 触发 panic
    // panic!("出错了！");
    
    // assert! - 断言
    assert!(1 + 1 == 2);
    
    // vec! - 创建向量
    let v = vec![1, 2, 3];
    
    // dbg! - 调试打印
    let x = 5;
    dbg!(x);
}
```

## Unsafe Rust

`unsafe` 关键字允许你执行 Rust 通常不允许的操作。

### Unsafe 的能力

在 `unsafe` 块中，你可以：

1. 解引用裸指针
2. 调用 unsafe 函数或方法
3. 访问或修改可变静态变量
4. 实现 unsafe trait
5. 访问 union 的字段

### 解引用裸指针

```rust
fn main() {
    let mut num = 5;
    
    // 创建裸指针
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
    
    unsafe {
        println!("r1 是: {}", *r1);
        println!("r2 是: {}", *r2);
    }
}
```

### 调用 Unsafe 函数

```rust
unsafe fn dangerous() {
    println!("这是 unsafe 函数");
}

fn main() {
    unsafe {
        dangerous();
    }
}
```

### 创建 Unsafe 代码的安全抽象

```rust
use std::slice;

fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
```

### 使用 extern 函数调用外部代码

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("C 的 abs(-3) = {}", abs(-3));
    }
}
```

### 访问或修改可变静态变量

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);
    
    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

### 实现 Unsafe Trait

```rust
unsafe trait Foo {
    // ...
}

unsafe impl Foo for i32 {
    // ...
}
```

## 外部函数接口（FFI）

FFI 允许 Rust 与其他语言（主要是 C）互操作。

### 调用 C 函数

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("C 的 abs(-3) = {}", abs(-3));
    }
}
```

### 从 Rust 调用 C 代码

```c
// add.c
int add(int a, int b) {
    return a + b;
}
```

```rust
// 需要 build.rs 来编译 C 代码
extern "C" {
    fn add(a: i32, b: i32) -> i32;
}

fn main() {
    unsafe {
        println!("5 + 3 = {}", add(5, 3));
    }
}
```

### 从 C 调用 Rust 函数

```rust
#[no_mangle]
pub extern "C" fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

```c
// main.c
extern int add(int a, int b);

int main() {
    printf("%d\n", add(5, 3));
    return 0;
}
```

### 使用 bindgen 生成绑定

```toml
# Cargo.toml
[build-dependencies]
bindgen = "0.65"
```

```rust
// build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .generate()
        .expect("无法生成绑定");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("无法写入绑定");
}
```

## 高级类型系统

### 类型别名

```rust
type Kilometers = i32;

fn main() {
    let distance: Kilometers = 5;
    let x: i32 = distance;  // 类型相同
}
```

### 从不返回的 never 类型

```rust
fn bar() -> ! {
    loop {
        // 无限循环，从不返回
    }
}

fn main() {
    let guess: u32 = match "42".parse() {
        Ok(num) => num,
        Err(_) => continue,  // continue 的类型是 !
    };
}
```

### 动态大小类型和 Sized trait

```rust
// str 是动态大小类型
let s1: &str = "Hello";
let s2: &str = &String::from("World");

// 使用 ?Sized 允许动态大小类型
fn generic<T: ?Sized>(t: &T) {
    // ...
}
```

## 高级函数和闭包

### 函数指针

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);
    println!("答案: {}", answer);
}
```

### 返回闭包

```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}

fn main() {
    let f = returns_closure();
    println!("{}", f(5));
}
```

## 实践示例

### 示例 1：自定义宏

```rust
macro_rules! my_vec {
    () => {
        Vec::new()
    };
    ($($x:expr),+ $(,)?) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )+
            temp_vec
        }
    };
}

fn main() {
    let v = my_vec![1, 2, 3];
    println!("{:?}", v);
}
```

### 示例 2：Unsafe 代码示例

```rust
use std::slice;

fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}

fn main() {
    let mut vector = vec![1, 2, 3, 4, 5, 6];
    let (left, right) = split_at_mut(&mut vector, 3);
    println!("左: {:?}, 右: {:?}", left, right);
}
```

### 示例 3：FFI 示例

```rust
// 调用系统函数
extern "C" {
    fn getpid() -> i32;
}

fn main() {
    unsafe {
        println!("进程 ID: {}", getpid());
    }
}
```

## 与其他语言对比

| 特性 | Rust | C++ | C | Python |
|------|------|-----|---|--------|
| **宏系统** | 声明式 + 过程宏 | 模板元编程 | 预处理器 | 无 |
| **Unsafe** | 显式 unsafe 块 | 默认 unsafe | 默认 unsafe | 无 |
| **FFI** | 原生支持 | 原生支持 | 原生 | ctypes |

**Rust 特点**：
- 强大的宏系统
- 显式的 unsafe 标记
- 原生 FFI 支持

## 总结

- **宏**：声明式宏和过程宏，用于代码生成
- **Unsafe Rust**：允许执行通常不允许的操作，需要显式标记
- **FFI**：与其他语言（主要是 C）互操作
- **高级类型**：类型别名、never 类型、动态大小类型
- **函数指针**：将函数作为值传递

继续学习：[性能优化和调试](./16-性能优化和调试.md) 学习如何优化和调试 Rust 程序！

