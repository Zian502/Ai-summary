# 智能指针

智能指针是 Rust 中管理堆上数据的重要工具。它们不仅存储数据，还包含额外的元数据和功能。Rust 标准库提供了多种智能指针类型。

## 什么是智能指针

智能指针通常使用结构体实现，实现了 `Deref` 和 `Drop` trait。

- **`Deref`**：允许智能指针像引用一样工作
- **`Drop`**：允许在值离开作用域时运行代码

### 与引用的区别

- **引用**：只借用数据
- **智能指针**：拥有数据

## Box<T>

`Box<T>` 是最简单的智能指针，允许在堆上分配数据。

### 基本使用

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}  // b 离开作用域时，Box 和它指向的数据都会被释放
```

### 使用场景

#### 1. 递归类型

```rust
// 编译时无法知道 List 的大小
// enum List {
//     Cons(i32, List),  // 错误！
//     Nil,
// }

// 使用 Box 解决
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```

#### 2. 转移大数据的所有权

```rust
fn main() {
    let large_data = vec![0; 1000000];
    let boxed_data = Box::new(large_data);
    // 只转移 Box 的所有权，而不是整个向量
}
```

#### 3. 实现 trait 对象

```rust
trait Draw {
    fn draw(&self);
}

struct Button;
impl Draw for Button {
    fn draw(&self) {
        println!("绘制按钮");
    }
}

fn main() {
    let button: Box<dyn Draw> = Box::new(Button);
    button.draw();
}
```

## Rc<T>（引用计数）

`Rc<T>` 是引用计数智能指针，允许多个所有者。

### 基本使用

```rust
use std::rc::Rc;

enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("创建 a 后，a 的引用计数 = {}", Rc::strong_count(&a));
    
    let b = Cons(3, Rc::clone(&a));
    println!("创建 b 后，a 的引用计数 = {}", Rc::strong_count(&a));
    
    {
        let c = Cons(4, Rc::clone(&a));
        println!("创建 c 后，a 的引用计数 = {}", Rc::strong_count(&a));
    }
    
    println!("c 离开作用域后，a 的引用计数 = {}", Rc::strong_count(&a));
}
```

### 特点

- **只读共享**：`Rc<T>` 只允许不可变引用
- **单线程**：只能在单线程中使用
- **引用计数**：当最后一个 `Rc<T>` 离开作用域时，数据被释放

## RefCell<T> 和内部可变性

`RefCell<T>` 允许在运行时检查借用规则，而不是编译时。

### 内部可变性

内部可变性是 Rust 的设计模式，允许你即使在有不可变引用时也能修改数据。

```rust
use std::cell::RefCell;

struct MockMessenger {
    sent_messages: RefCell<Vec<String>>,
}

impl MockMessenger {
    fn new() -> MockMessenger {
        MockMessenger {
            sent_messages: RefCell::new(vec![]),
        }
    }
    
    fn send(&self, message: &str) {
        // self 是不可变的，但可以修改内部数据
        self.sent_messages.borrow_mut().push(String::from(message));
    }
}

fn main() {
    let messenger = MockMessenger::new();
    messenger.send("消息 1");
    messenger.send("消息 2");
    
    assert_eq!(messenger.sent_messages.borrow().len(), 2);
}
```

### 借用规则

`RefCell<T>` 在运行时检查借用规则：

- 在任意给定时间，只能拥有一个可变引用或多个不可变引用
- 违反规则会导致 panic

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);
    
    // 不可变借用
    let r1 = data.borrow();
    let r2 = data.borrow();
    // let r3 = data.borrow_mut();  // 运行时 panic！
    
    println!("{}, {}", r1, r2);
}
```

## Rc<RefCell<T>>

组合 `Rc<T>` 和 `RefCell<T>` 可以实现多个所有者且可变的数据。

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let value = Rc::new(RefCell::new(5));
    
    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));
    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));
    
    *value.borrow_mut() += 10;
    
    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
```

## Arc<T>（原子引用计数）

`Arc<T>` 是线程安全的引用计数智能指针。

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(vec![1, 2, 3]);
    
    for i in 0..3 {
        let data = Arc::clone(&data);
        thread::spawn(move || {
            println!("线程 {}: {:?}", i, data);
        });
    }
    
    thread::sleep(std::time::Duration::from_secs(1));
}
```

### Rc<T> vs Arc<T>

| 特性 | Rc<T> | Arc<T> |
|------|-------|--------|
| 线程安全 | ❌ | ✅ |
| 性能 | 更快 | 稍慢（原子操作） |
| 使用场景 | 单线程 | 多线程 |

## Mutex<T>

`Mutex<T>` 提供互斥锁，用于多线程环境中的共享数据。

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("结果: {}", *counter.lock().unwrap());
}
```

## 智能指针对比

| 类型 | 所有者数量 | 可变性 | 线程安全 | 使用场景 |
|------|-----------|--------|---------|---------|
| **Box<T>** | 1 | 可变 | ✅ | 堆分配、递归类型 |
| **Rc<T>** | 多个 | 不可变 | ❌ | 单线程共享 |
| **RefCell<T>** | 1 | 运行时可变 | ❌ | 内部可变性 |
| **Arc<T>** | 多个 | 不可变 | ✅ | 多线程共享 |
| **Mutex<T>** | 1 | 运行时可变 | ✅ | 多线程互斥 |

## 实践示例

### 示例 1：树结构

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct TreeNode {
    value: i32,
    children: RefCell<Vec<Rc<TreeNode>>>,
}

fn main() {
    let leaf = Rc::new(TreeNode {
        value: 3,
        children: RefCell::new(vec![]),
    });
    
    let branch = Rc::new(TreeNode {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
```

### 示例 2：观察者模式

```rust
use std::rc::Rc;
use std::cell::RefCell;

type Observer = Rc<dyn Fn(&str)>;

struct Subject {
    observers: RefCell<Vec<Observer>>,
}

impl Subject {
    fn new() -> Self {
        Subject {
            observers: RefCell::new(vec![]),
        }
    }
    
    fn attach(&self, observer: Observer) {
        self.observers.borrow_mut().push(observer);
    }
    
    fn notify(&self, event: &str) {
        for observer in self.observers.borrow().iter() {
            observer(event);
        }
    }
}

fn main() {
    let subject = Subject::new();
    
    let observer1: Observer = Rc::new(|event| {
        println!("观察者 1 收到: {}", event);
    });
    
    let observer2: Observer = Rc::new(|event| {
        println!("观察者 2 收到: {}", event);
    });
    
    subject.attach(Rc::clone(&observer1));
    subject.attach(Rc::clone(&observer2));
    
    subject.notify("事件 1");
}
```

### 示例 3：多线程计数器

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for i in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
            println!("线程 {}: 计数器 = {}", i, *num);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终结果: {}", *counter.lock().unwrap());
}
```

## 与其他语言对比

| 语言 | 智能指针 | 线程安全 | 性能 |
|------|---------|---------|------|
| **Rust** | Box、Rc、Arc 等 | 编译时/运行时检查 | 零成本 |
| **C++** | unique_ptr、shared_ptr | 手动管理 | 零成本 |
| **Java** | 无（GC 管理） | 运行时检查 | 有开销 |
| **Python** | 无（GC 管理） | GIL | 有开销 |
| **Swift** | 引用计数 | 编译时检查 | 有开销 |

**Rust 特点**：
- 多种智能指针类型，适合不同场景
- 编译时和运行时检查结合
- 零成本抽象

## 总结

- **Box<T>**：堆分配，单所有者
- **Rc<T>**：引用计数，多所有者，单线程
- **RefCell<T>**：内部可变性，运行时检查
- **Arc<T>**：线程安全的引用计数
- **Mutex<T>**：互斥锁，多线程安全
- **组合使用**：`Rc<RefCell<T>>`、`Arc<Mutex<T>>` 等

继续学习：[并发编程](./14-并发编程.md) 学习 Rust 的并发编程模型！

