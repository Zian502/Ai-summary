# 并发编程

Rust 提供了强大的并发编程支持，包括线程、消息传递和异步编程。Rust 的所有权系统在编译时防止数据竞争。

## 线程

### 创建线程

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("线程中的数字: {}", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("主线程中的数字: {}", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```

### 使用 move 闭包

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("这是向量: {:?}", v);
    });

    handle.join().unwrap();
}
```

## 消息传递

Rust 的并发模型基于"消息传递"：通过通道（channel）在线程间传递消息。

### 基本使用

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("收到: {}", received);
}
```

### 发送多个值

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("收到: {}", received);
    }
}
```

### 多个发送者

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();
    let tx1 = mpsc::Sender::clone(&tx);

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
        }
    });

    for received in rx {
        println!("收到: {}", received);
    }
}
```

## 共享状态

### Mutex（互斥锁）

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("结果: {}", *counter.lock().unwrap());
}
```

### RwLock（读写锁）

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn main() {
    let data = Arc::new(RwLock::new(0));
    let mut handles = vec![];

    // 多个读线程
    for i in 0..5 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let reader = data.read().unwrap();
            println!("读线程 {}: {}", i, *reader);
        });
        handles.push(handle);
    }

    // 写线程
    let data = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut writer = data.write().unwrap();
        *writer += 1;
    });
    handles.push(handle);

    for handle in handles {
        handle.join().unwrap();
    }
}
```

## 异步编程

Rust 的异步编程基于 `async/await` 语法。

### 基本概念

```rust
async fn hello() {
    println!("Hello, async!");
}

fn main() {
    let future = hello();
    // 需要运行时来执行 future
}
```

### 使用 tokio 运行时

```toml
# Cargo.toml
[dependencies]
tokio = { version = "1", features = ["full"] }
```

```rust
use tokio::time::{sleep, Duration};

async fn hello() {
    println!("Hello");
    sleep(Duration::from_secs(1)).await;
    println!("World");
}

#[tokio::main]
async fn main() {
    hello().await;
}
```

### 并发执行多个异步任务

```rust
use tokio::time::{sleep, Duration};

async fn task(name: &str, duration: u64) {
    println!("任务 {} 开始", name);
    sleep(Duration::from_secs(duration)).await;
    println!("任务 {} 完成", name);
}

#[tokio::main]
async fn main() {
    // 并发执行
    tokio::join!(
        task("A", 2),
        task("B", 1),
        task("C", 3),
    );
}
```

### 使用 spawn 创建任务

```rust
use tokio::time::{sleep, Duration};

async fn task(name: &str) {
    for i in 1..=5 {
        println!("任务 {}: {}", name, i);
        sleep(Duration::from_millis(100)).await;
    }
}

#[tokio::main]
async fn main() {
    let handle1 = tokio::spawn(task("A"));
    let handle2 = tokio::spawn(task("B"));

    handle1.await.unwrap();
    handle2.await.unwrap();
}
```

### 异步通道

```rust
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (mut tx, mut rx) = mpsc::channel(100);

    tokio::spawn(async move {
        for i in 0..10 {
            tx.send(i).await.unwrap();
        }
    });

    while let Some(message) = rx.recv().await {
        println!("收到: {}", message);
    }
}
```

## 实践示例

### 示例 1：多线程计算

```rust
use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    let data = Arc::new(Mutex::new(vec![]));
    let mut handles = vec![];

    for i in 0..10 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let mut vec = data.lock().unwrap();
            vec.push(i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("结果: {:?}", data.lock().unwrap());
}
```

### 示例 2：异步 HTTP 客户端

```toml
# Cargo.toml
[dependencies]
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }
```

```rust
use reqwest;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let urls = vec![
        "https://api.github.com",
        "https://httpbin.org/get",
    ];

    let mut handles = vec![];
    for url in urls {
        let handle = tokio::spawn(async move {
            let resp = reqwest::get(url).await?;
            resp.text().await
        });
        handles.push(handle);
    }

    for handle in handles {
        if let Ok(Ok(text)) = handle.await {
            println!("响应长度: {}", text.len());
        }
    }

    Ok(())
}
```

### 示例 3：生产者-消费者模式

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    // 生产者
    thread::spawn(move || {
        for i in 0..10 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });

    // 消费者
    for received in rx {
        println!("处理: {}", received);
    }
}
```

### 示例 4：异步任务池

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

async fn worker(id: usize, semaphore: Arc<Semaphore>) {
    let _permit = semaphore.acquire().await.unwrap();
    println!("工作者 {} 开始工作", id);
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    println!("工作者 {} 完成工作", id);
}

#[tokio::main]
async fn main() {
    let semaphore = Arc::new(Semaphore::new(3)); // 最多 3 个并发任务
    let mut handles = vec![];

    for i in 0..10 {
        let semaphore = Arc::clone(&semaphore);
        let handle = tokio::spawn(worker(i, semaphore));
        handles.push(handle);
    }

    for handle in handles {
        handle.await.unwrap();
    }
}
```

## 并发安全

### Send 和 Sync trait

- **Send**：类型可以安全地在线程间传递所有权
- **Sync**：类型可以安全地通过引用在线程间共享

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];
    
    // Vec<T> 实现了 Send（如果 T 实现了 Send）
    thread::spawn(move || {
        println!("{:?}", v);
    }).join().unwrap();
}
```

### 避免数据竞争

Rust 的所有权系统在编译时防止数据竞争：

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let data = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let mut num = data.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("结果: {}", *data.lock().unwrap());
}
```

## 与其他语言对比

| 语言 | 并发模型 | 数据竞争 | 性能 |
|------|---------|---------|------|
| **Rust** | 线程 + async/await | 编译时检查 | 零成本 |
| **Go** | Goroutine | 运行时检查 | 高效 |
| **Java** | 线程 | 运行时检查 | 有开销 |
| **Python** | 线程（GIL） | GIL 限制 | 受限 |
| **C++** | 线程 | 手动同步 | 零成本 |

**Rust 特点**：
- 编译时防止数据竞争
- 零成本抽象
- 强大的异步支持

## 总结

- **线程**：使用 `thread::spawn` 创建线程
- **消息传递**：使用 `mpsc::channel` 在线程间传递消息
- **共享状态**：使用 `Mutex`、`RwLock` 等保护共享数据
- **异步编程**：使用 `async/await` 和运行时（如 tokio）
- **并发安全**：`Send` 和 `Sync` trait 保证线程安全

继续学习：[高级特性](./15-高级特性.md) 学习宏、unsafe Rust 和 FFI！

