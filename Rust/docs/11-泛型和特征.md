# 泛型和特征

泛型允许你编写可以处理多种类型的代码，而特征（trait）定义了类型必须实现的功能。这两个特性是 Rust 类型系统的核心。

## 泛型（Generics）

泛型让你可以编写不指定具体类型的代码，提高代码复用性。

### 函数中的泛型

```rust
// 不使用泛型（重复代码）
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

// 使用泛型
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&number_list);
    println!("最大数字: {}", result);
    
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&char_list);
    println!("最大字符: {}", result);
}
```

### 结构体中的泛型

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    // let mixed = Point { x: 5, y: 4.0 };  // 错误！类型必须相同
}

// 多个泛型参数
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let integer_and_float = Point { x: 5, y: 4.0 };
    let string_and_char = Point { x: "Hello", y: 'c' };
}
```

### 枚举中的泛型

```rust
enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

### 方法中的泛型

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

// 为特定类型实现方法
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

// 多个泛型参数
impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}
```

### 性能

Rust 的泛型是**零成本抽象**：使用泛型的代码与手写具体类型的代码性能相同（单态化）。

```rust
// 泛型代码
fn generic_function<T>(x: T) -> T {
    x
}

// 编译后会被单态化为具体类型
// fn generic_function_i32(x: i32) -> i32 { x }
// fn generic_function_f64(x: f64) -> f64 { x }
```

## 特征（Traits）

特征定义了类型必须实现的功能，类似于其他语言中的接口。

### 定义特征

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

### 实现特征

```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

### 默认实现

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(阅读更多...)")
    }
    
    fn summarize_author(&self) -> String;
    
    // 默认实现可以调用其他方法
    fn summarize_full(&self) -> String {
        format!("(阅读更多... 来自 {})", self.summarize_author())
    }
}
```

### 作为参数

```rust
// 使用 trait bound
pub fn notify(item: impl Summary) {
    println!("突发新闻! {}", item.summarize());
}

// 使用 trait bound 语法（更明确）
pub fn notify<T: Summary>(item: T) {
    println!("突发新闻! {}", item.summarize());
}

// 多个 trait bound
pub fn notify(item: impl Summary + Display) {
    // ...
}

// 使用 where 子句（更清晰）
fn some_function<T, U>(t: T, u: U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
    // ...
}
```

### 作为返回值

```rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("当然，正如你可能已经知道的那样，人们"),
        reply: false,
        retweet: false,
    }
}
```

### 使用 trait bound 有条件地实现方法

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

// 只为实现了 Display 和 PartialOrd 的 Pair 实现方法
impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("最大成员是 x = {}", self.x);
        } else {
            println!("最大成员是 y = {}", self.y);
        }
    }
}
```

## 常用标准库特征

### Display 和 Debug

```rust
use std::fmt;

#[derive(Debug)]  // 自动实现 Debug
struct Point {
    x: i32,
    y: i32,
}

// 手动实现 Display
impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

fn main() {
    let p = Point { x: 1, y: 2 };
    println!("{:?}", p);  // Debug: Point { x: 1, y: 2 }
    println!("{}", p);    // Display: (1, 2)
}
```

### Clone 和 Copy

```rust
#[derive(Clone, Copy)]  // Copy 需要实现 Clone
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = p1;  // 复制（因为实现了 Copy）
    println!("{:?}, {:?}", p1, p2);  // 两者都有效
}
```

### PartialEq 和 Eq

```rust
#[derive(PartialEq)]  // 部分相等
struct Point {
    x: i32,
    y: i32,
}

// Eq 需要 PartialEq（浮点数不能实现 Eq，因为 NaN != NaN）
#[derive(PartialEq, Eq)]
struct IntegerPoint {
    x: i32,
    y: i32,
}
```

### PartialOrd 和 Ord

```rust
#[derive(PartialOrd, PartialEq)]  // 部分排序
struct Point {
    x: i32,
    y: i32,
}

// 需要先实现 PartialEq
#[derive(PartialOrd, Ord, PartialEq, Eq)]
struct IntegerPoint {
    x: i32,
    y: i32,
}
```

### Iterator trait

```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let mut counter = Counter::new();
    for i in counter {
        println!("{}", i);
    }
}
```

## 实践示例

### 示例 1：泛型函数

```rust
fn largest<T: PartialOrd>(list: &[T]) -> Option<&T> {
    if list.is_empty() {
        return None;
    }
    
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    Some(largest)
}

fn main() {
    let numbers = vec![34, 50, 25, 100, 65];
    if let Some(max) = largest(&numbers) {
        println!("最大数字: {}", max);
    }
}
```

### 示例 2：自定义 trait

```rust
trait Area {
    fn area(&self) -> f64;
}

struct Circle {
    radius: f64,
}

impl Area for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}

struct Rectangle {
    width: f64,
    height: f64,
}

impl Area for Rectangle {
    fn area(&self) -> f64 {
        self.width * self.height
    }
}

fn print_area<T: Area>(shape: &T) {
    println!("面积: {}", shape.area());
}

fn main() {
    let circle = Circle { radius: 5.0 };
    let rect = Rectangle { width: 10.0, height: 20.0 };
    
    print_area(&circle);
    print_area(&rect);
}
```

### 示例 3：泛型结构体

```rust
struct Container<T> {
    value: T,
}

impl<T> Container<T> {
    fn new(value: T) -> Self {
        Container { value }
    }
    
    fn get(&self) -> &T {
        &self.value
    }
}

fn main() {
    let container = Container::new(42);
    println!("值: {}", container.get());
}
```

## 与其他语言对比

| 语言 | 泛型 | 接口/Trait | 性能 |
|------|------|-----------|------|
| **Rust** | 编译时单态化 | Trait | 零成本 |
| **C++** | 模板 | 无（C++20 概念） | 零成本 |
| **Java** | 类型擦除 | Interface | 有开销 |
| **Go** | 无（Go 1.18+ 有） | Interface | 有开销 |
| **Swift** | 泛型 | Protocol | 零成本 |

**Rust 特点**：
- 编译时单态化，零成本抽象
- Trait 系统强大且灵活
- 类型安全，编译时检查

## 总结

- **泛型**：编写可处理多种类型的代码，编译时单态化
- **Trait**：定义类型必须实现的功能
- **Trait bound**：限制泛型类型必须实现特定 trait
- **常用 trait**：Display、Debug、Clone、Copy、PartialEq、Eq 等
- **性能**：零成本抽象，运行时无开销

继续学习：[生命周期](./12-生命周期.md) 学习如何管理引用的生命周期！

