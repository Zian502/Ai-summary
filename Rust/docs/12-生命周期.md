# 生命周期

生命周期（lifetimes）是 Rust 中确保引用有效性的机制。理解生命周期对于编写安全的 Rust 代码至关重要。

## 什么是生命周期

生命周期是引用保持有效的作用域。大多数时候，生命周期是隐式推断的，但有时需要显式标注。

### 悬垂引用问题

```rust
// 这段代码无法编译
// fn main() {
//     let r;
//     {
//         let x = 5;
//         r = &x;  // x 的生命周期结束，r 成为悬垂引用
//     }
//     println!("r: {}", r);
// }
```

### 借用检查器

Rust 的借用检查器通过比较作用域来确保所有借用都是有效的。

```rust
fn main() {
    let x = 5;  // x 的生命周期开始
    
    let r = &x;  // r 借用 x
    
    println!("r: {}", r);  // r 和 x 都有效
}  // r 和 x 的生命周期结束
```

## 函数中的生命周期注解

### 为什么需要生命周期注解

```rust
// 这段代码无法编译，因为不知道返回的引用指向 x 还是 y
// fn longest(x: &str, y: &str) -> &str {
//     if x.len() > y.len() {
//         x
//     } else {
//         y
//     }
// }

// 使用生命周期注解
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("最长的字符串是 {}", result);
    }
}
```

### 生命周期注解语法

```rust
// 生命周期参数以单引号开头，通常是小写字母
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
```

### 函数签名中的生命周期注解

```rust
// 生命周期注解告诉 Rust：返回的引用的生命周期
// 与参数中较短的那个生命周期相同
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

### 实际应用

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    // println!("最长的字符串是 {}", result);  // 错误！string2 已失效
}
```

## 结构体中的生命周期注解

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("找不到 '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    // novel 和 first_sentence 必须比 i 活得更久
}
```

## 生命周期省略规则

在某些情况下，Rust 可以自动推断生命周期，不需要显式注解。

### 三条规则

1. **每个是引用的参数都有它自己的生命周期参数**
2. **如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数**
3. **如果方法有多个输入生命周期参数并且其中一个参数是 `&self` 或 `&mut self`，说明是对象的方法，那么所有输出生命周期参数被赋予 `self` 的生命周期**

```rust
// 规则 1：每个参数都有自己的生命周期
fn first_word(s: &str) -> &str {  // 省略前：fn first_word<'a>(s: &'a str) -> &'a str
    // ...
}

// 规则 2：单个输入生命周期
fn longest(x: &str, y: &str) -> &str {  // 无法推断，需要显式注解
    // ...
}

// 规则 3：方法中的 self
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        // 返回值的生命周期是 self 的生命周期
        self.part
    }
}
```

## 方法中的生命周期注解

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    // 规则 3 适用：返回值的生命周期是 self 的生命周期
    fn level(&self) -> i32 {
        3
    }
    
    // 需要显式注解
    fn announce_and_return_part<'b>(&self, announcement: &'b str) -> &'b str {
        println!("注意！{}", announcement);
        self.part
    }
}
```

## 静态生命周期

`'static` 生命周期表示整个程序的持续时间。

```rust
// 字符串字面量有 'static 生命周期
let s: &'static str = "I have a static lifetime.";

// 错误示例：不能返回局部变量的引用
// fn invalid() -> &'static str {
//     let s = String::from("hello");
//     &s  // 错误！s 不是 'static
// }
```

## 泛型、Trait Bound 和生命周期的组合

```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("公告! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

## 实践示例

### 示例 1：返回引用

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}

fn main() {
    let my_string = String::from("hello world");
    let word = first_word(&my_string);
    println!("第一个单词: {}", word);
}
```

### 示例 2：结构体中的引用

```rust
struct Config<'a> {
    host: &'a str,
    port: u16,
}

impl<'a> Config<'a> {
    fn new(host: &'a str, port: u16) -> Self {
        Config { host, port }
    }
    
    fn get_host(&self) -> &'a str {
        self.host
    }
}

fn main() {
    let host = "localhost";
    let config = Config::new(host, 8080);
    println!("主机: {}", config.get_host());
}
```

### 示例 3：多个生命周期参数

```rust
fn longest_with_an_announcement<'a, 'b>(
    x: &'a str,
    y: &'b str,
) -> &'a str
where
    'b: 'a,  // 'b 必须至少和 'a 一样长
{
    if x.len() > y.len() {
        x
    } else {
        x  // 必须返回 'a 生命周期的引用
    }
}
```

## 常见错误和解决方案

### 错误 1：返回局部变量的引用

```rust
// 错误
// fn invalid() -> &str {
//     let s = String::from("hello");
//     &s  // 错误！s 在函数结束时被释放
// }

// 解决方案：返回所有权
fn valid() -> String {
    let s = String::from("hello");
    s  // 返回所有权
}
```

### 错误 2：生命周期不匹配

```rust
// 错误
// fn main() {
//     let result;
//     let string2 = String::from("xyz");
//     {
//         let string1 = String::from("long string is long");
//         result = longest(string1.as_str(), string2.as_str());
//     }
//     println!("最长的字符串是 {}", result);  // 错误！
// }

// 解决方案：确保引用的生命周期足够长
fn main() {
    let string1 = String::from("long string is long");
    let string2 = String::from("xyz");
    let result = longest(string1.as_str(), string2.as_str());
    println!("最长的字符串是 {}", result);
}
```

## 与其他语言对比

| 语言 | 内存管理 | 生命周期检查 | 性能 |
|------|---------|------------|------|
| **Rust** | 所有权系统 | 编译时检查 | 零成本 |
| **C++** | 手动/智能指针 | 运行时可能出错 | 零成本 |
| **Java** | GC | 运行时检查 | 有开销 |
| **Go** | GC | 运行时检查 | 有开销 |
| **Swift** | ARC | 编译时检查 | 有开销 |

**Rust 特点**：
- 编译时检查，零运行时开销
- 防止悬垂引用
- 需要理解生命周期注解

## 总结

- **生命周期**：引用保持有效的作用域
- **生命周期注解**：显式标注引用的生命周期关系
- **生命周期省略**：编译器可以自动推断的情况
- **静态生命周期**：`'static` 表示整个程序期间
- **常见模式**：函数参数、结构体字段、方法中的生命周期

继续学习：[智能指针](./13-智能指针.md) 学习 Rust 中的智能指针类型！

