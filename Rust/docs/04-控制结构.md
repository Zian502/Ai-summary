# 控制结构

Rust 提供了多种控制流结构：条件语句（`if`、`else`）、循环（`loop`、`while`、`for`）和模式匹配（`match`）。

## 条件语句

### if 表达式

在 Rust 中，`if` 是一个表达式，可以返回值。

```rust
fn main() {
    let number = 6;
    
    // 基本 if 语句
    if number < 5 {
        println!("条件为真");
    } else {
        println!("条件为假");
    }
    
    // 多个条件
    if number % 4 == 0 {
        println!("数字可以被 4 整除");
    } else if number % 3 == 0 {
        println!("数字可以被 3 整除");
    } else if number % 2 == 0 {
        println!("数字可以被 2 整除");
    } else {
        println!("数字不能被 4、3 或 2 整除");
    }
    
    // if 作为表达式（注意：分支必须返回相同类型）
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };
    println!("number 的值: {}", number);
    
    // 错误示例：类型不匹配
    // let number = if condition {
    //     5
    // } else {
    //     "six"  // 错误！类型不匹配
    // };
}
```

### 与其他语言对比

| 语言 | if 语法 | 返回值 |
|------|---------|--------|
| **Rust** | `if condition { }` | 表达式，可返回值 |
| **C++** | `if (condition) { }` | 语句，不返回值 |
| **Go** | `if condition { }` | 语句，不返回值 |
| **Python** | `if condition:` | 语句，不返回值 |
| **JavaScript** | `if (condition) { }` | 语句，不返回值 |
| **Scala** | `if (condition) { }` | 表达式，可返回值 |

**Rust 特点**：
- `if` 是表达式，不是语句
- 不需要括号（但可以加）
- 条件必须是 `bool` 类型（不能隐式转换）

## 循环

Rust 提供了三种循环：`loop`、`while` 和 `for`。

### loop 循环

`loop` 创建一个无限循环，直到遇到 `break`。

```rust
fn main() {
    let mut counter = 0;
    
    // 无限循环
    loop {
        counter += 1;
        if counter == 10 {
            break;
        }
    }
    println!("counter: {}", counter);
    
    // loop 返回值
    let result = loop {
        counter += 1;
        if counter == 20 {
            break counter * 2;  // 返回值
        }
    };
    println!("result: {}", result);
    
    // 循环标签（用于嵌套循环）
    let mut count = 0;
    'counting_up: loop {
        let mut remaining = 10;
        loop {
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;  // 跳出外层循环
            }
            remaining -= 1;
        }
        count += 1;
    }
    println!("最终 count: {}", count);
}
```

### while 循环

`while` 循环在条件为真时执行。

```rust
fn main() {
    let mut number = 3;
    
    // 基本 while 循环
    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }
    println!("LIFTOFF!!!");
    
    // while 遍历数组
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;
    
    while index < 5 {
        println!("值: {}", a[index]);
        index += 1;
    }
}
```

### for 循环

`for` 循环是 Rust 中最常用的循环，用于遍历集合。

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    
    // 遍历数组
    for element in a.iter() {
        println!("值: {}", element);
    }
    
    // 使用范围（Range）
    for number in 1..4 {  // 1, 2, 3（不包含 4）
        println!("{}!", number);
    }
    
    for number in 1..=4 {  // 1, 2, 3, 4（包含 4）
        println!("{}!", number);
    }
    
    // 倒序
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    
    // 遍历字符串
    let s = "hello";
    for c in s.chars() {
        println!("{}", c);
    }
    
    // 带索引的遍历
    for (index, value) in a.iter().enumerate() {
        println!("索引 {}: 值 {}", index, value);
    }
    
    // 遍历向量
    let v = vec![1, 2, 3, 4, 5];
    for item in &v {  // 借用，不获取所有权
        println!("{}", item);
    }
}
```

### 与其他语言对比

| 语言 | 无限循环 | 条件循环 | 遍历循环 |
|------|---------|---------|---------|
| **Rust** | `loop { }` | `while condition { }` | `for item in iter { }` |
| **C++** | `while (true) { }` | `while (condition) { }` | `for (auto item : container) { }` |
| **Go** | `for { }` | `for condition { }` | `for i, v := range slice { }` |
| **Python** | `while True:` | `while condition:` | `for item in iterable:` |
| **JavaScript** | `while (true) { }` | `while (condition) { }` | `for (item of iterable) { }` |

**Rust 特点**：
- `loop` 是无限循环，可以返回值
- `for` 循环最常用，安全且高效
- 使用迭代器，避免索引越界

## 控制流实践

### 示例 1：猜数字游戏（简化版）

```rust
use std::io;

fn main() {
    let secret_number = 42;
    let mut guess = String::new();
    
    loop {
        println!("请输入你的猜测:");
        
        io::stdin()
            .read_line(&mut guess)
            .expect("读取输入失败");
        
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("请输入有效数字！");
                guess.clear();
                continue;
            }
        };
        
        match guess.cmp(&secret_number) {
            std::cmp::Ordering::Less => println!("太小了！"),
            std::cmp::Ordering::Greater => println!("太大了！"),
            std::cmp::Ordering::Equal => {
                println!("你赢了！");
                break;
            }
        }
        
        guess.clear();
    }
}
```

### 示例 2：斐波那契数列

```rust
fn main() {
    let n = 10;
    
    // 使用循环计算
    let mut a = 0;
    let mut b = 1;
    
    println!("斐波那契数列前 {} 项:", n);
    for i in 0..n {
        if i == 0 {
            println!("F(0) = {}", a);
        } else if i == 1 {
            println!("F(1) = {}", b);
        } else {
            let next = a + b;
            println!("F({}) = {}", i, next);
            a = b;
            b = next;
        }
    }
}
```

### 示例 3：查找数组中的元素

```rust
fn main() {
    let numbers = [1, 2, 3, 4, 5];
    let target = 3;
    
    // 使用 for 循环查找
    let mut found = false;
    for number in numbers.iter() {
        if *number == target {
            found = true;
            break;
        }
    }
    
    if found {
        println!("找到了 {}", target);
    } else {
        println!("未找到 {}", target);
    }
    
    // 使用迭代器方法（更 Rust 风格）
    if numbers.iter().any(|&x| x == target) {
        println!("找到了 {}", target);
    }
    
    // 查找并返回索引
    if let Some(index) = numbers.iter().position(|&x| x == target) {
        println!("{} 在索引 {}", target, index);
    }
}
```

### 示例 4：嵌套循环

```rust
fn main() {
    // 打印乘法表
    for i in 1..=9 {
        for j in 1..=i {
            print!("{}x{}={}\t", j, i, i * j);
        }
        println!();
    }
    
    // 使用循环标签跳出外层循环
    'outer: for x in 0..10 {
        'inner: for y in 0..10 {
            if x == 5 && y == 5 {
                break 'outer;  // 跳出外层循环
            }
            if y == 3 {
                continue 'inner;  // 继续内层循环
            }
            println!("x: {}, y: {}", x, y);
        }
    }
}
```

## 模式匹配（初步）

`match` 是 Rust 中强大的控制流结构，将在后续章节详细介绍。

```rust
fn main() {
    let number = 3;
    
    // match 表达式
    match number {
        1 => println!("一"),
        2 => println!("二"),
        3 => println!("三"),
        _ => println!("其他"),  // 默认分支
    }
    
    // match 返回值
    let description = match number {
        1 => "一",
        2 => "二",
        3 => "三",
        _ => "其他",
    };
    println!("描述: {}", description);
}
```

## 条件编译

Rust 支持条件编译，可以根据配置选择性地编译代码。

```rust
fn main() {
    // 条件编译
    #[cfg(target_os = "linux")]
    println!("运行在 Linux 上");
    
    #[cfg(target_os = "windows")]
    println!("运行在 Windows 上");
    
    #[cfg(target_os = "macos")]
    println!("运行在 macOS 上");
    
    // 自定义条件
    #[cfg(feature = "my_feature")]
    println!("启用了 my_feature");
}

// 条件编译函数
#[cfg(target_os = "linux")]
fn linux_only_function() {
    println!("这是 Linux 专用函数");
}
```

## 最佳实践

### 1. 优先使用 for 循环

```rust
// 推荐：使用 for 循环
let v = vec![1, 2, 3];
for item in &v {
    println!("{}", item);
}

// 不推荐：使用 while 循环遍历
// let mut index = 0;
// while index < v.len() {
//     println!("{}", v[index]);
//     index += 1;
// }
```

### 2. 使用迭代器方法

```rust
let numbers = vec![1, 2, 3, 4, 5];

// 推荐：使用迭代器方法
let sum: i32 = numbers.iter().sum();
let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect();

// 不推荐：手动循环
// let mut sum = 0;
// for n in &numbers {
//     sum += n;
// }
```

### 3. 使用 if let 简化模式匹配

```rust
let some_value = Some(3);

// 推荐：使用 if let
if let Some(value) = some_value {
    println!("值: {}", value);
}

// 不推荐：使用 match
// match some_value {
//     Some(value) => println!("值: {}", value),
//     None => {},
// }
```

## 总结

- **条件语句**：`if` 是表达式，可以返回值，条件必须是 `bool` 类型
- **循环类型**：
  - `loop`：无限循环，可以返回值
  - `while`：条件循环
  - `for`：遍历集合，最常用
- **控制流**：`break` 跳出循环，`continue` 继续下一次迭代
- **循环标签**：用于嵌套循环中精确控制跳转
- **最佳实践**：优先使用 `for` 循环和迭代器方法

继续学习：[函数](./05-函数.md) 深入了解 Rust 的函数系统！

