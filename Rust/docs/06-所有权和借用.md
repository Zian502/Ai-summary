# 所有权和借用

所有权（Ownership）是 Rust 最独特的特性，它使 Rust 能够在没有垃圾回收器的情况下保证内存安全。理解所有权是掌握 Rust 的关键。

## 所有权规则

Rust 的所有权系统基于以下规则：

1. **每个值都有一个所有者（owner）**
2. **值在任一时刻有且只有一个所有者**
3. **当所有者离开作用域时，值会被丢弃（drop）**

### 作用域和所有权

```rust
fn main() {
    // s 在这里无效，尚未声明
    let s = String::from("hello");  // s 从这开始有效
    
    // 使用 s
    println!("{}", s);
}  // s 的作用域结束，s 被释放（drop）
```

### 移动（Move）

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1 被移动到 s2
    
    // println!("{}", s1);  // 错误！s1 不再有效
    
    println!("{}", s2);  // 正确
}
```

**与其他语言对比**：

| 语言 | 赋值行为 | 内存管理 |
|------|---------|---------|
| **Rust** | 移动（Move） | 编译时检查 |
| **C++** | 复制或移动（取决于类型） | 手动管理 |
| **Python** | 引用计数 | 自动 GC |
| **Java** | 引用复制 | 自动 GC |
| **Go** | 值复制或引用 | 自动 GC |

### 复制（Copy）trait

实现了 `Copy` trait 的类型在赋值时会被复制，而不是移动：

```rust
fn main() {
    let x = 5;
    let y = x;  // x 被复制（因为 i32 实现了 Copy）
    
    println!("x: {}, y: {}", x, y);  // 两者都有效
    
    // Copy 类型示例
    let a = 5;      // i32
    let b = 3.14;   // f64
    let c = true;   // bool
    let d = 'c';    // char
    
    // 元组（如果所有元素都是 Copy）
    let tuple = (1, 2.0, true);
    let tuple2 = tuple;  // 复制
    println!("{:?}, {:?}", tuple, tuple2);
}
```

**常见的 Copy 类型**：
- 所有整数类型（i32、u32 等）
- 布尔类型（bool）
- 浮点类型（f32、f64）
- 字符类型（char）
- 只包含 Copy 类型的元组

## 所有权和函数

### 值传递

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s);  // s 被移动到函数中
    // println!("{}", s);  // 错误！s 不再有效
    
    let x = 5;
    makes_copy(x);  // x 被复制
    println!("x: {}", x);  // 正确！x 仍然有效
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
}  // some_string 在这里被释放

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
}  // some_integer 离开作用域，但因为是 Copy 类型，没有影响
```

### 返回值转移所有权

```rust
fn main() {
    let s1 = gives_ownership();  // 函数返回值所有权转移给 s1
    
    let s2 = String::from("hello");
    let s3 = takes_and_gives_back(s2);  // s2 被移动，返回值所有权转移给 s3
    
    // println!("{}", s2);  // 错误！s2 不再有效
    println!("s1: {}, s3: {}", s1, s3);
}

fn gives_ownership() -> String {
    let some_string = String::from("hello");
    some_string  // 所有权转移给调用者
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string  // 所有权转移给调用者
}
```

## 引用和借用（Borrowing）

引用允许你使用值但不获取其所有权。

### 不可变引用

```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);  // 传递引用
    println!("'{}' 的长度是 {}", s1, len);  // s1 仍然有效
}

fn calculate_length(s: &String) -> usize {
    s.len()
}  // s 离开作用域，但不会释放它指向的数据
```

### 可变引用

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);  // 传递可变引用
    println!("{}", s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

### 引用规则

1. **在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用**
2. **引用必须总是有效的**

```rust
fn main() {
    let mut s = String::from("hello");
    
    // 多个不可变引用是可以的
    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2);  // 正确
    
    // 可变引用
    let r3 = &mut s;
    // println!("{}, {}", r1, r2);  // 错误！不能同时有可变和不可变引用
    println!("{}", r3);  // 正确
}
```

### 悬垂引用（Dangling References）

Rust 编译器会防止悬垂引用：

```rust
// 这段代码无法编译
// fn main() {
//     let reference_to_nothing = dangle();
// }
//
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s  // 错误！返回局部变量的引用
// }  // s 在这里被释放

// 正确的方式：返回所有权
fn main() {
    let s = no_dangle();
    println!("{}", s);
}

fn no_dangle() -> String {
    let s = String::from("hello");
    s  // 返回所有权
}
```

## 切片（Slices）

切片是对集合中一段连续元素的引用。

### 字符串切片

```rust
fn main() {
    let s = String::from("hello world");
    
    let hello = &s[0..5];    // "hello"
    let world = &s[6..11];   // "world"
    
    // 完整切片
    let full = &s[..];
    
    // 从开始到索引
    let start = &s[..5];
    
    // 从索引到结束
    let end = &s[6..];
    
    // 字符串字面量就是切片
    let s: &str = "hello world";
    
    // 函数接受字符串切片
    let my_string = String::from("hello world");
    let word = first_word(&my_string[..]);
    println!("第一个单词: {}", word);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}
```

### 数组切片

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    
    let slice = &a[1..3];  // [2, 3]
    println!("{:?}", slice);
}
```

## 所有权实践

### 示例 1：避免不必要的移动

```rust
fn main() {
    let s = String::from("hello");
    
    // 不好的方式：移动所有权
    // let len = calculate_length_move(s);
    // println!("{}", s);  // 错误！
    
    // 好的方式：使用引用
    let len = calculate_length_borrow(&s);
    println!("'{}' 的长度是 {}", s, len);  // 正确
}

fn calculate_length_move(s: String) -> usize {
    s.len()
}

fn calculate_length_borrow(s: &String) -> usize {
    s.len()
}
```

### 示例 2：返回引用

```rust
fn main() {
    let s = String::from("hello world");
    let word = first_word(&s);
    println!("第一个单词: {}", word);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}
```

### 示例 3：结构体中的所有权

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    
    // user1 的所有字段都被移动到 user2
    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        ..user1  // 使用剩余字段
    };
    
    // println!("{}", user1.email);  // 错误！user1 的部分字段已被移动
    println!("{}", user2.email);
}
```

## 与其他语言的内存管理对比

| 特性 | Rust | C++ | Java | Python |
|------|------|-----|------|--------|
| **内存安全** | 编译时保证 | 运行时可能出错 | 运行时检查 | 运行时检查 |
| **性能开销** | 零成本 | 零成本 | GC 开销 | GC 开销 |
| **并发安全** | 编译时保证 | 需要手动同步 | 运行时检查 | GIL 限制 |
| **学习曲线** | 陡峭 | 中等 | 平缓 | 平缓 |

## 常见错误和解决方案

### 错误 1：使用已移动的值

```rust
// 错误示例
// let s1 = String::from("hello");
// let s2 = s1;
// println!("{}", s1);  // 错误！

// 解决方案 1：使用引用
let s1 = String::from("hello");
let s2 = &s1;
println!("{}", s1);  // 正确

// 解决方案 2：克隆
let s1 = String::from("hello");
let s2 = s1.clone();
println!("{}", s1);  // 正确
```

### 错误 2：同时拥有可变和不可变引用

```rust
// 错误示例
// let mut s = String::from("hello");
// let r1 = &s;
// let r2 = &mut s;  // 错误！

// 解决方案：分离作用域
let mut s = String::from("hello");
{
    let r1 = &s;
    println!("{}", r1);
}  // r1 在这里离开作用域
let r2 = &mut s;  // 现在可以创建可变引用
```

### 错误 3：返回局部变量的引用

```rust
// 错误示例
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s  // 错误！
// }

// 解决方案：返回所有权
fn no_dangle() -> String {
    let s = String::from("hello");
    s  // 返回所有权
}
```

## 最佳实践

### 1. 优先使用引用

```rust
// 推荐：使用引用
fn process_string(s: &String) {
    // ...
}

// 不推荐：移动所有权（除非必要）
// fn process_string(s: String) {
//     // ...
// }
```

### 2. 使用字符串切片

```rust
// 推荐：接受 &str（更灵活）
fn first_word(s: &str) -> &str {
    // ...
}

// 不推荐：只接受 &String
// fn first_word(s: &String) -> &str {
//     // ...
// }
```

### 3. 使用 Clone 当需要所有权时

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();  // 显式克隆
    println!("{}, {}", s1, s2);
}
```

## 总结

- **所有权规则**：每个值有一个所有者，值在任一时刻只有一个所有者，所有者离开作用域时值被释放
- **移动（Move）**：赋值时，非 Copy 类型会被移动
- **复制（Copy）**：实现了 Copy trait 的类型会被复制
- **引用（Reference）**：允许使用值但不获取所有权
- **借用（Borrowing）**：通过引用访问数据
- **引用规则**：同一时间只能有一个可变引用或多个不可变引用
- **切片（Slice）**：对集合中一段连续元素的引用

继续学习：[结构体和枚举](./07-结构体和枚举.md) 学习如何定义自定义类型！

