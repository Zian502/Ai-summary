# 函数

函数是 Rust 程序的基本构建块。Rust 中的函数具有强大的特性，包括函数指针、闭包和函数式编程支持。

## 函数定义

### 基本语法

```rust
// 函数定义使用 fn 关键字
fn main() {
    println!("Hello from main!");
    another_function();
    
    // 调用带参数的函数
    print_labeled_measurement(5, 'h');
    
    // 调用有返回值的函数
    let x = five();
    println!("five() 返回值: {}", x);
    
    let y = plus_one(5);
    println!("plus_one(5) 返回值: {}", y);
}

// 无参数函数
fn another_function() {
    println!("Hello from another function!");
}

// 带参数函数（参数必须标注类型）
fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("测量值: {}{}", value, unit_label);
}

// 有返回值的函数（使用 -> 指定返回类型）
fn five() -> i32 {
    5  // 注意：没有分号，这是表达式，不是语句
}

fn plus_one(x: i32) -> i32 {
    x + 1  // 表达式作为返回值
    // 如果加上分号，就变成语句，返回 () 类型
    // x + 1;  // 错误！返回类型不匹配
}

// 显式 return 语句
fn explicit_return(x: i32) -> i32 {
    return x + 1;  // 显式返回
    // return 后面的代码不会执行
}
```

### 语句和表达式

```rust
fn main() {
    // 语句（Statement）：执行操作但不返回值
    let x = 6;  // 这是一个语句
    
    // 表达式（Expression）：计算并返回值
    let y = {
        let x = 3;
        x + 1  // 这是表达式，没有分号
    };
    println!("y: {}", y);  // 输出：y: 4
    
    // 函数调用是表达式
    let z = five();
    
    // 宏调用是表达式
    let w = println!("Hello");  // 返回 () 类型
}
```

### 与其他语言对比

| 语言 | 函数定义 | 返回值 | 最后表达式 |
|------|---------|--------|-----------|
| **Rust** | `fn name() -> Type` | 显式 `->` | 最后表达式自动返回 |
| **C++** | `Type name()` | 显式 `return` | 需要 `return` |
| **Go** | `func name() Type` | 显式 `return` | 需要 `return` |
| **Java** | `Type name()` | 显式 `return` | 需要 `return` |
| **Python** | `def name():` | 显式 `return` | 需要 `return` |
| **JavaScript** | `function name() {}` | 显式 `return` | 需要 `return` |

**Rust 特点**：
- 最后表达式自动作为返回值（无分号）
- 显式返回类型注解
- 函数是一等公民

## 函数参数

### 值传递

```rust
fn main() {
    let x = 5;
    takes_ownership(x);  // x 被复制（因为 i32 实现了 Copy trait）
    println!("x 仍然可用: {}", x);
    
    let s = String::from("hello");
    takes_ownership_string(s);  // s 被移动
    // println!("{}", s);  // 错误！s 已被移动
}

fn takes_ownership(some_integer: i32) {
    println!("{}", some_integer);
}

fn takes_ownership_string(some_string: String) {
    println!("{}", some_string);
}  // some_string 在这里被释放
```

### 引用传递（借用）

```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);  // 传递引用
    println!("'{}' 的长度是 {}", s1, len);  // s1 仍然可用
    
    let mut s2 = String::from("hello");
    change(&mut s2);  // 可变引用
    println!("{}", s2);
}

// 不可变引用
fn calculate_length(s: &String) -> usize {
    s.len()
}  // s 离开作用域，但不会释放它指向的数据

// 可变引用
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

### 可变参数

```rust
fn main() {
    let mut x = 5;
    add_one(&mut x);
    println!("x: {}", x);  // 输出：x: 6
}

fn add_one(n: &mut i32) {
    *n += 1;  // 解引用并修改
}
```

## 返回值

### 返回单个值

```rust
fn main() {
    let result = add(2, 3);
    println!("结果: {}", result);
}

fn add(a: i32, b: i32) -> i32 {
    a + b  // 表达式返回
}
```

### 返回多个值（使用元组）

```rust
fn main() {
    let (min, max) = min_max(10, 5);
    println!("min: {}, max: {}", min, max);
    
    let (quotient, remainder) = divide(10, 3);
    println!("商: {}, 余数: {}", quotient, remainder);
}

fn min_max(a: i32, b: i32) -> (i32, i32) {
    if a < b {
        (a, b)
    } else {
        (b, a)
    }
}

fn divide(dividend: i32, divisor: i32) -> (i32, i32) {
    (dividend / divisor, dividend % divisor)
}
```

### 提前返回

```rust
fn find_number(numbers: &[i32], target: i32) -> Option<usize> {
    for (index, &number) in numbers.iter().enumerate() {
        if number == target {
            return Some(index);  // 提前返回
        }
    }
    None
}
```

## 函数作为值

### 函数指针

```rust
fn main() {
    // 函数指针
    let f: fn(i32) -> i32 = add_one;
    let result = f(5);
    println!("结果: {}", result);
    
    // 函数指针作为参数
    apply_twice(add_one, 5);
}

fn add_one(x: i32) -> i32 {
    x + 1
}

fn apply_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(f(arg))
}
```

### 函数作为返回值

```rust
fn main() {
    let add = make_adder(10);
    println!("{}", add(5));  // 输出：15
}

fn make_adder(x: i32) -> fn(i32) -> i32 {
    fn add(y: i32) -> i32 {
        x + y  // 错误！不能捕获外部变量
    }
    add
}

// 使用闭包代替（见下文）
```

## 闭包（Closures）

闭包是可以捕获其环境的匿名函数。

### 基本语法

```rust
fn main() {
    // 闭包语法：|参数| 表达式
    let add_one = |x| x + 1;
    println!("{}", add_one(5));  // 输出：6
    
    // 带类型注解的闭包
    let add_one_typed = |x: i32| -> i32 { x + 1 };
    
    // 多参数闭包
    let add = |x, y| x + y;
    println!("{}", add(2, 3));  // 输出：5
    
    // 多行闭包
    let multiply = |x: i32, y: i32| {
        let result = x * y;
        result
    };
    println!("{}", multiply(3, 4));  // 输出：12
}
```

### 捕获环境

```rust
fn main() {
    let x = 4;
    
    // 闭包可以捕获外部变量
    let equal_to_x = |z| z == x;
    println!("{}", equal_to_x(4));  // true
    
    // 移动捕获（使用 move 关键字）
    let x = vec![1, 2, 3];
    let equal_to_x = move |z| z == x.len();
    // println!("{:?}", x);  // 错误！x 已被移动
    println!("{}", equal_to_x(3));  // true
}
```

### 闭包类型

闭包有三种捕获方式，对应三个 trait：

```rust
fn main() {
    let x = 5;
    
    // Fn：不可变借用
    let print_x = || println!("{}", x);
    print_x();
    println!("x: {}", x);  // x 仍然可用
    
    // FnMut：可变借用
    let mut y = 5;
    let mut add_to_y = || {
        y += 1;
        println!("y: {}", y);
    };
    add_to_y();
    
    // FnOnce：获取所有权
    let z = vec![1, 2, 3];
    let consume_z = move || {
        println!("{:?}", z);
    };
    consume_z();
    // println!("{:?}", z);  // 错误！z 已被移动
}
```

### 闭包作为参数

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // 使用闭包处理数据
    let doubled: Vec<i32> = numbers.iter()
        .map(|x| x * 2)
        .collect();
    println!("{:?}", doubled);
    
    // 过滤
    let evens: Vec<&i32> = numbers.iter()
        .filter(|&x| x % 2 == 0)
        .collect();
    println!("{:?}", evens);
}

// 接受闭包作为参数的函数
fn apply<F>(f: F, value: i32) -> i32
where
    F: Fn(i32) -> i32,
{
    f(value)
}
```

### 与其他语言对比

| 语言 | 闭包语法 | 捕获方式 |
|------|---------|---------|
| **Rust** | `\|x\| x + 1` | 自动推断（Fn/FnMut/FnOnce） |
| **C++** | `[=](int x) { return x + 1; }` | 显式指定捕获方式 |
| **Go** | `func(x int) int { return x + 1 }` | 不支持闭包（但有匿名函数） |
| **Python** | `lambda x: x + 1` | 自动捕获 |
| **JavaScript** | `x => x + 1` | 自动捕获 |
| **Java** | `x -> x + 1` | 自动捕获（Java 8+） |

**Rust 特点**：
- 闭包是零成本抽象
- 自动推断捕获方式
- 三种 trait（Fn、FnMut、FnOnce）提供灵活性

## 高阶函数

### 函数式编程风格

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    // map：转换每个元素
    let doubled: Vec<i32> = numbers.iter()
        .map(|x| x * 2)
        .collect();
    
    // filter：过滤元素
    let evens: Vec<&i32> = numbers.iter()
        .filter(|&x| x % 2 == 0)
        .collect();
    
    // fold：累积
    let sum: i32 = numbers.iter()
        .fold(0, |acc, x| acc + x);
    
    // chain：链式操作
    let result: Vec<i32> = numbers.iter()
        .map(|x| x * 2)
        .filter(|&x| x > 5)
        .collect();
    
    println!("结果: {:?}", result);
}
```

### 自定义高阶函数

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];
    
    let result = map(numbers, |x| x * 2);
    println!("{:?}", result);
}

fn map<F, T, U>(items: Vec<T>, f: F) -> Vec<U>
where
    F: Fn(T) -> U,
{
    let mut result = Vec::new();
    for item in items {
        result.push(f(item));
    }
    result
}
```

## 方法（Methods）

方法是在结构体或枚举上定义的函数。

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 关联函数（类似静态方法）
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }
    
    // 实例方法（第一个参数是 &self）
    fn area(&self) -> u32 {
        self.width * self.height
    }
    
    // 可变方法（第一个参数是 &mut self）
    fn set_width(&mut self, width: u32) {
        self.width = width;
    }
    
    // 获取所有权的方法（第一个参数是 self）
    fn into_tuple(self) -> (u32, u32) {
        (self.width, self.height)
    }
}

fn main() {
    let rect = Rectangle::new(30, 50);
    println!("面积: {}", rect.area());
}
```

## 实践示例

### 示例 1：计算器

```rust
fn main() {
    println!("5 + 3 = {}", add(5, 3));
    println!("5 - 3 = {}", subtract(5, 3));
    println!("5 * 3 = {}", multiply(5, 3));
    println!("10 / 3 = {}", divide(10, 3));
}

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn subtract(a: i32, b: i32) -> i32 {
    a - b
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

fn divide(a: i32, b: i32) -> i32 {
    a / b
}
```

### 示例 2：使用闭包实现缓存

```rust
use std::collections::HashMap;

struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    calculation: T,
    value: HashMap<u32, u32>,
}

impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: HashMap::new(),
        }
    }
    
    fn value(&mut self, arg: u32) -> u32 {
        match self.value.get(&arg) {
            Some(v) => *v,
            None => {
                let v = (self.calculation)(arg);
                self.value.insert(arg, v);
                v
            }
        }
    }
}

fn main() {
    let mut expensive_result = Cacher::new(|num| {
        println!("计算中...");
        num * 2
    });
    
    println!("{}", expensive_result.value(5));
    println!("{}", expensive_result.value(5));  // 使用缓存
}
```

### 示例 3：函数式编程

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    // 计算偶数的平方和
    let result: i32 = numbers.iter()
        .filter(|&x| x % 2 == 0)
        .map(|x| x * x)
        .sum();
    
    println!("偶数的平方和: {}", result);
    
    // 查找第一个大于 5 的偶数
    if let Some(value) = numbers.iter()
        .find(|&x| *x > 5 && x % 2 == 0) {
        println!("找到: {}", value);
    }
}
```

## 总结

- **函数定义**：使用 `fn` 关键字，必须标注参数和返回类型
- **返回值**：最后表达式自动返回，或使用 `return` 语句
- **函数指针**：函数是一等公民，可以作为值传递
- **闭包**：匿名函数，可以捕获环境，有三种 trait（Fn、FnMut、FnOnce）
- **高阶函数**：接受或返回函数的函数，支持函数式编程
- **方法**：在类型上定义的函数，第一个参数是 `self`

继续学习：[所有权和借用](./06-所有权和借用.md) 深入了解 Rust 的核心特性！

