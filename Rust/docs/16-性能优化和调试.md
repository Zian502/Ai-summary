# 性能优化和调试

本章介绍如何优化 Rust 程序的性能和进行调试。

## 性能优化

### 编译优化

```toml
# Cargo.toml
[profile.release]
opt-level = 3        # 优化级别（0-3，s/z）
lto = true           # 链接时优化
codegen-units = 1    # 代码生成单元（更慢但更优化）
panic = 'abort'      # 不展开堆栈
```

### 使用 Release 模式

```bash
# 开发模式（快速编译）
cargo build

# 发布模式（优化）
cargo build --release
```

### 性能分析工具

#### 使用 perf（Linux）

```bash
# 安装 perf
sudo apt-get install linux-perf

# 分析程序
perf record --call-graph dwarf ./target/release/my_program
perf report
```

#### 使用 valgrind

```bash
# 安装 valgrind
sudo apt-get install valgrind

# 内存分析
valgrind --leak-check=full ./target/release/my_program

# 性能分析
valgrind --tool=callgrind ./target/release/my_program
```

#### 使用 flamegraph

```toml
# Cargo.toml
[dev-dependencies]
flamegraph = "0.4"
```

```bash
cargo flamegraph --bin my_program
```

### 代码优化技巧

#### 1. 避免不必要的克隆

```rust
// 不推荐：不必要的克隆
fn process_string(s: String) {
    let s2 = s.clone();
    // ...
}

// 推荐：使用引用
fn process_string(s: &String) {
    // ...
}
```

#### 2. 使用迭代器

```rust
// 推荐：使用迭代器（零成本抽象）
let sum: i32 = numbers.iter().sum();

// 不推荐：手动循环
let mut sum = 0;
for n in &numbers {
    sum += n;
}
```

#### 3. 预分配容量

```rust
// 推荐：预分配容量
let mut vec = Vec::with_capacity(1000);
for i in 0..1000 {
    vec.push(i);
}

// 不推荐：动态扩容
let mut vec = Vec::new();
for i in 0..1000 {
    vec.push(i);
}
```

#### 4. 使用合适的集合类型

```rust
// 需要快速查找：使用 HashMap
use std::collections::HashMap;
let mut map = HashMap::new();

// 需要有序：使用 BTreeMap
use std::collections::BTreeMap;
let mut map = BTreeMap::new();

// 需要去重：使用 HashSet
use std::collections::HashSet;
let mut set = HashSet::new();
```

#### 5. 避免不必要的分配

```rust
// 推荐：使用字符串切片
fn process(s: &str) {
    // ...
}

// 不推荐：不必要的 String 分配
fn process(s: String) {
    // ...
}
```

### 基准测试

```toml
# Cargo.toml
[dev-dependencies]
criterion = "0.5"
```

```rust
// benches/my_benchmark.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 1,
        n => fibonacci(n-1) + fibonacci(n-2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

```bash
cargo bench
```

## 调试

### 使用 println! 和 dbg!

```rust
fn main() {
    let x = 5;
    println!("x = {}", x);
    
    let y = dbg!(x * 2);
    println!("y = {}", y);
}
```

### 使用调试器

#### GDB

```bash
# 安装 GDB
sudo apt-get install gdb

# 编译调试版本
cargo build

# 启动 GDB
gdb target/debug/my_program

# GDB 命令
# break main          # 设置断点
# run                 # 运行程序
# next                # 下一行
# step                # 进入函数
# print variable      # 打印变量
# continue            # 继续执行
```

#### LLDB

```bash
# macOS 自带 LLDB
lldb target/debug/my_program

# LLDB 命令
# breakpoint set --name main
# run
# next
# step
# print variable
# continue
```

### VS Code 调试配置

```json
// .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug",
            "cargo": {
                "args": ["build"],
                "filter": {
                    "name": "my_program",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        }
    ]
}
```

### 日志

#### 使用 log crate

```toml
# Cargo.toml
[dependencies]
log = "0.4"
env_logger = "0.10"
```

```rust
use log::{debug, info, warn, error};

fn main() {
    env_logger::init();
    
    debug!("这是调试信息");
    info!("这是一般信息");
    warn!("这是警告");
    error!("这是错误");
}
```

```bash
# 设置日志级别
RUST_LOG=debug cargo run
RUST_LOG=info cargo run
```

#### 使用 tracing

```toml
# Cargo.toml
[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"
```

```rust
use tracing::{info, debug, error};

#[tracing::instrument]
fn my_function(x: i32) {
    info!("函数被调用，x = {}", x);
}

fn main() {
    tracing_subscriber::fmt::init();
    
    my_function(42);
}
```

## 内存分析

### 使用 Miri（未定义行为检查）

```bash
# 安装 Miri
rustup component add miri

# 运行 Miri
cargo miri test
```

### 使用 AddressSanitizer

```bash
# 编译时启用 AddressSanitizer
RUSTFLAGS="-Z sanitizer=address" cargo test --target x86_64-unknown-linux-gnu
```

## 性能监控

### 使用 sysinfo

```toml
# Cargo.toml
[dependencies]
sysinfo = "0.29"
```

```rust
use sysinfo::{System, SystemExt, ProcessExt};

fn main() {
    let mut system = System::new_all();
    system.refresh_all();
    
    println!("总内存: {} KB", system.total_memory());
    println!("可用内存: {} KB", system.available_memory());
    
    for (pid, process) in system.processes() {
        println!("[{}] {}: {} KB", pid, process.name(), process.memory());
    }
}
```

## 最佳实践

### 1. 测量，不要猜测

```rust
use std::time::Instant;

fn main() {
    let start = Instant::now();
    
    // 你的代码
    expensive_operation();
    
    let duration = start.elapsed();
    println!("耗时: {:?}", duration);
}
```

### 2. 使用合适的算法和数据结构

```rust
// 需要快速查找：使用 HashMap
use std::collections::HashMap;

// 需要有序：使用 BTreeMap
use std::collections::BTreeMap;

// 需要去重：使用 HashSet
use std::collections::HashSet;
```

### 3. 避免过早优化

```rust
// 先写清晰的代码
fn process_data(data: &[i32]) -> Vec<i32> {
    data.iter().map(|x| x * 2).collect()
}

// 测量性能后再优化
```

### 4. 使用编译器提示

```rust
// 使用 #[inline] 提示编译器内联
#[inline]
fn small_function(x: i32) -> i32 {
    x * 2
}
```

### 5. 使用 unsafe 时要小心

```rust
// 只在必要时使用 unsafe
unsafe {
    // 确保这是安全的
}
```

## 常见性能问题

### 1. 不必要的克隆

```rust
// 问题：不必要的克隆
let s2 = s.clone();

// 解决：使用引用
let s2 = &s;
```

### 2. 动态分配过多

```rust
// 问题：频繁分配
for i in 0..1000 {
    let vec = Vec::new();
    // ...
}

// 解决：重用分配
let mut vec = Vec::new();
for i in 0..1000 {
    vec.clear();
    // ...
}
```

### 3. 不必要的边界检查

```rust
// Rust 编译器通常会自动优化，但可以显式使用 get_unchecked
unsafe {
    let value = slice.get_unchecked(index);
}
```

## 工具推荐

### 开发工具

- **rust-analyzer**：LSP 服务器，提供代码补全和错误检查
- **clippy**：静态分析工具，发现常见错误和性能问题
- **rustfmt**：代码格式化工具

### 性能工具

- **perf**：Linux 性能分析工具
- **flamegraph**：火焰图生成工具
- **criterion**：基准测试框架
- **valgrind**：内存和性能分析工具

### 调试工具

- **GDB/LLDB**：调试器
- **Miri**：未定义行为检查
- **tracing**：结构化日志和追踪

## 总结

- **编译优化**：使用 release 模式和优化选项
- **性能分析**：使用 perf、valgrind、flamegraph 等工具
- **代码优化**：避免不必要的克隆、使用迭代器、预分配容量
- **调试**：使用 GDB/LLDB、日志、Miri
- **基准测试**：使用 criterion 进行基准测试
- **最佳实践**：测量、使用合适的算法、避免过早优化

恭喜你完成了 Rust 从入门到进阶的学习！🎉

现在你已经掌握了 Rust 的核心概念和高级特性，可以开始构建实际项目了。继续实践和探索 Rust 生态系统，享受 Rust 带来的安全性和性能！
