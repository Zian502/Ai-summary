# 错误处理

Rust 没有异常，而是使用 `Result<T, E>` 类型来处理可恢复的错误，使用 `panic!` 宏来处理不可恢复的错误。这种设计使错误处理更加明确和安全。

## 不可恢复错误：panic!

当程序遇到不可恢复的错误时，可以使用 `panic!` 宏。

### 使用 panic!

```rust
fn main() {
    panic!("崩溃并显示这条消息");
}

// 另一种触发 panic 的方式
fn main() {
    let v = vec![1, 2, 3];
    v[99];  // 数组越界，会 panic
}
```

### 设置 panic 行为

```rust
// 在 Cargo.toml 中设置
// [profile.release]
// panic = 'abort'  // 不展开堆栈，直接终止

// 或者在代码中
fn main() {
    // 默认行为：展开（unwind）
    // 可以设置环境变量 RUST_BACKTRACE=1 查看堆栈跟踪
}
```

### 何时使用 panic!

- **示例、原型和测试**：快速失败
- **程序状态无效**：当某些假设、保证、协议或不变性被打破时
- **调用者传递了无效数据**：应该返回 `Result` 而不是 panic

## 可恢复错误：Result<T, E>

`Result` 枚举用于处理可能失败的操作。

### Result 定义

```rust
enum Result<T, E> {
    Ok(T),   // 成功，包含值
    Err(E),  // 错误，包含错误信息
}
```

### 基本使用

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");
    
    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("打开文件失败: {:?}", error);
        }
    };
}
```

### 匹配不同的错误

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");
    
    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("创建文件失败: {:?}", e),
            },
            other_error => {
                panic!("打开文件失败: {:?}", other_error);
            }
        },
    };
}
```

### 失败时 panic 的快捷方法

#### unwrap

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap();
    // 如果 Result 是 Err，unwrap 会调用 panic!
}
```

#### expect

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt")
        .expect("打开 hello.txt 失败");
    // 类似 unwrap，但可以自定义错误消息
}
```

### 传播错误

```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");
    
    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),  // 传播错误
    };
    
    let mut s = String::new();
    
    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),  // 传播错误
    }
}
```

### ? 运算符

`?` 运算符是传播错误的快捷方式。

```rust
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;  // 如果错误，直接返回
    let mut s = String::new();
    f.read_to_string(&mut s)?;  // 如果错误，直接返回
    Ok(s)
}

// 更简洁的版本
fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();
    File::open("hello.txt")?.read_to_string(&mut s)?;
    Ok(s)
}

// 最简洁的版本（使用标准库函数）
use std::fs;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```

### ? 运算符可以用于返回 Result 的函数

```rust
use std::fs::File;

fn main() {
    // main 函数可以返回 Result
    // ? 运算符可以用于返回 Result 的函数
}

// main 函数也可以返回 Result
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let f = File::open("hello.txt")?;
    Ok(())
}
```

### 链式调用

```rust
use std::fs::File;
use std::io::Read;

fn read_file() -> Result<String, std::io::Error> {
    let mut file = File::open("hello.txt")?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

## Option<T> 和错误处理

`Option<T>` 用于处理可能不存在的值。

### Option 定义

```rust
enum Option<T> {
    Some(T),
    None,
}
```

### 基本使用

```rust
fn find_user(id: u32) -> Option<String> {
    if id == 1 {
        Some("Alice".to_string())
    } else {
        None
    }
}

fn main() {
    match find_user(1) {
        Some(name) => println!("找到用户: {}", name),
        None => println!("用户不存在"),
    }
}
```

### Option 的常用方法

```rust
fn main() {
    let some_number = Some(5);
    let some_string = Some("a string");
    let absent_number: Option<i32> = None;
    
    // unwrap：获取值，如果是 None 则 panic
    let x = some_number.unwrap();  // 5
    
    // unwrap_or：提供默认值
    let y = absent_number.unwrap_or(0);  // 0
    
    // unwrap_or_else：使用闭包计算默认值
    let z = absent_number.unwrap_or_else(|| 42);
    
    // map：转换值
    let doubled = some_number.map(|x| x * 2);  // Some(10)
    
    // and_then：链式操作
    let result = some_number.and_then(|x| Some(x * 2));
    
    // or_else：提供替代值
    let result = absent_number.or_else(|| Some(42));
    
    // filter：过滤
    let filtered = some_number.filter(|&x| x > 3);  // Some(5)
    let filtered2 = Some(2).filter(|&x| x > 3);  // None
}
```

### Option 和 Result 的转换

```rust
// Option 转 Result
let some_option = Some(5);
let result: Result<i32, &str> = some_option.ok_or("没有值");

// Result 转 Option
let result: Result<i32, &str> = Ok(5);
let option = result.ok();  // Some(5)

let result: Result<i32, &str> = Err("错误");
let option = result.ok();  // None
```

## 自定义错误类型

### 定义错误类型

```rust
use std::fmt;

#[derive(Debug)]
struct MyError {
    message: String,
}

impl fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for MyError {}

fn might_fail() -> Result<i32, MyError> {
    Err(MyError {
        message: "出错了".to_string(),
    })
}
```

### 使用 thiserror 库（推荐）

```rust
// 需要添加依赖：thiserror = "1.0"

use thiserror::Error;

#[derive(Error, Debug)]
enum MyError {
    #[error("IO 错误: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("解析错误: {0}")]
    Parse(#[from] std::num::ParseIntError),
    
    #[error("自定义错误: {message}")]
    Custom { message: String },
}

fn might_fail() -> Result<i32, MyError> {
    // 自动转换
    let num = "42".parse()?;
    Ok(num)
}
```

### 使用 anyhow 库（用于应用程序）

```rust
// 需要添加依赖：anyhow = "1.0"

use anyhow::{Context, Result};

fn read_file(path: &str) -> Result<String> {
    std::fs::read_to_string(path)
        .with_context(|| format!("无法读取文件: {}", path))
}

fn main() -> Result<()> {
    let content = read_file("config.txt")?;
    println!("{}", content);
    Ok(())
}
```

## 错误处理最佳实践

### 1. 使用 Result 而不是 panic!

```rust
// 推荐：返回 Result
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("除数不能为零".to_string())
    } else {
        Ok(a / b)
    }
}

// 不推荐：使用 panic!
// fn divide(a: f64, b: f64) -> f64 {
//     if b == 0.0 {
//         panic!("除数不能为零");
//     }
//     a / b
// }
```

### 2. 使用 ? 运算符传播错误

```rust
// 推荐：使用 ? 运算符
fn read_config() -> Result<String, std::io::Error> {
    std::fs::read_to_string("config.txt")?
}

// 不推荐：手动匹配
// fn read_config() -> Result<String, std::io::Error> {
//     match std::fs::read_to_string("config.txt") {
//         Ok(s) => Ok(s),
//         Err(e) => Err(e),
//     }
// }
```

### 3. 提供有意义的错误消息

```rust
use anyhow::{Context, Result};

fn read_user_data(user_id: u32) -> Result<String> {
    let path = format!("users/{}.json", user_id);
    std::fs::read_to_string(&path)
        .with_context(|| format!("无法读取用户 {} 的数据", user_id))
}
```

### 4. 使用 Option 表示可选值

```rust
// 推荐：使用 Option 表示可能不存在的值
fn find_user(id: u32) -> Option<User> {
    // ...
}

// 不推荐：使用 Result 表示可选值
// fn find_user(id: u32) -> Result<User, NotFoundError> {
//     // ...
// }
```

## 实践示例

### 示例 1：文件操作

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file_contents(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn main() {
    match read_file_contents("hello.txt") {
        Ok(contents) => println!("文件内容: {}", contents),
        Err(e) => eprintln!("错误: {}", e),
    }
}
```

### 示例 2：解析数字

```rust
fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
    s.parse()
}

fn main() {
    match parse_number("42") {
        Ok(n) => println!("数字: {}", n),
        Err(e) => eprintln!("解析错误: {}", e),
    }
}
```

### 示例 3：组合多个操作

```rust
use std::fs::File;
use std::io::{self, Read, Write};

fn copy_file(src: &str, dst: &str) -> Result<(), io::Error> {
    let mut src_file = File::open(src)?;
    let mut contents = String::new();
    src_file.read_to_string(&mut contents)?;
    
    let mut dst_file = File::create(dst)?;
    dst_file.write_all(contents.as_bytes())?;
    
    Ok(())
}
```

### 示例 4：自定义错误类型

```rust
use std::fmt;

#[derive(Debug)]
enum AppError {
    Io(std::io::Error),
    Parse(std::num::ParseIntError),
    Custom(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::Io(e) => write!(f, "IO 错误: {}", e),
            AppError::Parse(e) => write!(f, "解析错误: {}", e),
            AppError::Custom(msg) => write!(f, "自定义错误: {}", msg),
        }
    }
}

impl std::error::Error for AppError {}

impl From<std::io::Error> for AppError {
    fn from(err: std::io::Error) -> AppError {
        AppError::Io(err)
    }
}

impl From<std::num::ParseIntError> for AppError {
    fn from(err: std::num::ParseIntError) -> AppError {
        AppError::Parse(err)
    }
}

fn might_fail() -> Result<i32, AppError> {
    let contents = std::fs::read_to_string("number.txt")?;
    let num: i32 = contents.trim().parse()?;
    Ok(num)
}
```

## 与其他语言对比

| 语言 | 错误处理 | 类型安全 | 性能 |
|------|---------|---------|------|
| **Rust** | `Result<T, E>` | ✅ 编译时检查 | 零成本 |
| **Go** | `error` 接口 | ❌ 运行时检查 | 零成本 |
| **Java** | 异常 | ❌ 运行时检查 | 有开销 |
| **Python** | 异常 | ❌ 运行时检查 | 有开销 |
| **C++** | 异常或错误码 | ❌ 运行时检查 | 有开销 |

**Rust 特点**：
- 错误处理是类型系统的一部分
- 必须显式处理错误
- 零成本抽象
- 没有异常的开销

## 总结

- **panic!**：用于不可恢复的错误
- **Result<T, E>**：用于可恢复的错误
- **Option<T>**：用于可能不存在的值
- **? 运算符**：传播错误的快捷方式
- **自定义错误类型**：使用 `thiserror` 或 `anyhow` 库
- **最佳实践**：使用 `Result` 而不是 `panic!`，使用 `?` 传播错误

继续学习：[模块和包](./10-模块和包.md) 学习如何组织和管理 Rust 代码！

