# 状态管理

状态管理是 Flutter 应用开发的核心概念。本章介绍 Flutter 的状态管理方式，从基础的 setState 到高级的状态管理方案。

## 基础状态管理

### setState（本地状态）

setState 是 StatefulWidget 中最基础的状态管理方式，类似于 React 的 `useState`。

```dart
class Counter extends StatefulWidget {
  const Counter({super.key});
  
  @override
  State<Counter> createState() => _CounterState();
}

class _CounterState extends State<Counter> {
  int _count = 0;  // 状态变量
  
  void _increment() {
    setState(() {
      // 修改状态并触发重建
      _count++;
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: $_count'),
        ElevatedButton(
          onPressed: _increment,
          child: Text('Increment'),
        ),
      ],
    );
  }
}

// 与 React 对比
// React:
//   function Counter() {
//     const [count, setCount] = useState(0);
//     return (
//       <>
//         <Text>Count: {count}</Text>
//         <Button onClick={() => setCount(count + 1)}>Increment</Button>
//       </>
//     );
//   }
```

### 状态提升（State Lifting）

当多个 Widget 需要共享状态时，将状态提升到共同的父 Widget。

```dart
// 父 Widget 管理状态
class ParentWidget extends StatefulWidget {
  @override
  State<ParentWidget> createState() => _ParentWidgetState();
}

class _ParentWidgetState extends State<ParentWidget> {
  int _count = 0;
  
  void _increment() {
    setState(() => _count++);
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // 子 Widget 1 显示状态
        DisplayWidget(count: _count),
        // 子 Widget 2 修改状态
        ButtonWidget(onIncrement: _increment),
      ],
    );
  }
}

// 显示状态的 Widget
class DisplayWidget extends StatelessWidget {
  final int count;
  
  const DisplayWidget({super.key, required this.count});
  
  @override
  Widget build(BuildContext context) {
    return Text('Count: $count');
  }
}

// 修改状态的 Widget
class ButtonWidget extends StatelessWidget {
  final VoidCallback onIncrement;
  
  const ButtonWidget({super.key, required this.onIncrement});
  
  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onIncrement,
      child: Text('Increment'),
    );
  }
}

// 与 React 对比
// React:
//   function Parent() {
//     const [count, setCount] = useState(0);
//     return (
//       <>
//         <Display count={count} />
//         <Button onIncrement={() => setCount(count + 1)} />
//       </>
//     );
//   }
```

## Provider（推荐的状态管理方案）

Provider 是 Flutter 官方推荐的状态管理方案，类似于 React 的 Context API + Redux。

### 安装 Provider

```yaml
# pubspec.yaml
dependencies:
  provider: ^6.1.1
```

```bash
flutter pub get
```

### 基本使用

```dart
import 'package:provider/provider.dart';

// 1. 创建状态模型（类似于 Redux 的 Store）
class CounterModel extends ChangeNotifier {
  int _count = 0;
  
  int get count => _count;
  
  void increment() {
    _count++;
    notifyListeners();  // 通知监听者更新（类似于 React 的 setState）
  }
  
  void decrement() {
    _count--;
    notifyListeners();
  }
}

// 2. 在应用根部提供状态（类似于 React Context Provider）
void main() {
  runApp(
    ChangeNotifierProvider(
      create: (_) => CounterModel(),
      child: MyApp(),
    ),
  );
}

// 3. 在 Widget 中使用状态
class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // 方式 1: 使用 Consumer（类似于 React Context Consumer）
    return Consumer<CounterModel>(
      builder: (context, counter, child) {
        return Column(
          children: [
            Text('Count: ${counter.count}'),
            ElevatedButton(
              onPressed: counter.increment,
              child: Text('Increment'),
            ),
          ],
        );
      },
    );
    
    // 方式 2: 使用 Provider.of（类似于 React useContext）
    // final counter = Provider.of<CounterModel>(context);
    // return Text('Count: ${counter.count}');
    
    // 方式 3: 使用 context.watch（推荐，自动监听）
    // final counter = context.watch<CounterModel>();
    // return Text('Count: ${counter.count}');
    
    // 方式 4: 使用 context.read（不监听，仅读取）
    // final counter = context.read<CounterModel>();
    // counter.increment();
  }
}

// 与 React 对比
// React:
//   const CounterContext = createContext();
//   function App() {
//     const [count, setCount] = useState(0);
//     return (
//       <CounterContext.Provider value={{count, setCount}}>
//         <CounterWidget />
//       </CounterContext.Provider>
//     );
//   }
//   function CounterWidget() {
//     const {count, setCount} = useContext(CounterContext);
//     return <Text>Count: {count}</Text>;
//   }
```

### 多个 Provider

```dart
// 提供多个状态
void main() {
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => CounterModel()),
        ChangeNotifierProvider(create: (_) => UserModel()),
        ChangeNotifierProvider(create: (_) => ThemeModel()),
      ],
      child: MyApp(),
    ),
  );
}

// 使用多个状态
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final counter = context.watch<CounterModel>();
    final user = context.watch<UserModel>();
    final theme = context.watch<ThemeModel>();
    
    return Column(
      children: [
        Text('Count: ${counter.count}'),
        Text('User: ${user.name}'),
      ],
    );
  }
}
```

### 实际应用示例：购物车

```dart
// 购物车商品模型
class CartItem {
  final String id;
  final String name;
  final double price;
  int quantity;
  
  CartItem({
    required this.id,
    required this.name,
    required this.price,
    this.quantity = 1,
  });
  
  double get total => price * quantity;
}

// 购物车状态管理
class CartModel extends ChangeNotifier {
  final List<CartItem> _items = [];
  
  List<CartItem> get items => List.unmodifiable(_items);
  
  int get itemCount => _items.length;
  
  double get totalPrice {
    return _items.fold(0, (sum, item) => sum + item.total);
  }
  
  void addItem(CartItem item) {
    final existingIndex = _items.indexWhere((i) => i.id == item.id);
    if (existingIndex >= 0) {
      _items[existingIndex].quantity++;
    } else {
      _items.add(item);
    }
    notifyListeners();
  }
  
  void removeItem(String id) {
    _items.removeWhere((item) => item.id == id);
    notifyListeners();
  }
  
  void updateQuantity(String id, int quantity) {
    final index = _items.indexWhere((item) => item.id == id);
    if (index >= 0) {
      if (quantity <= 0) {
        _items.removeAt(index);
      } else {
        _items[index].quantity = quantity;
      }
      notifyListeners();
    }
  }
  
  void clear() {
    _items.clear();
    notifyListeners();
  }
}

// 使用购物车
class CartScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final cart = context.watch<CartModel>();
    
    return Scaffold(
      appBar: AppBar(
        title: Text('Shopping Cart'),
        actions: [
          IconButton(
            icon: Badge(
              label: Text('${cart.itemCount}'),
              child: Icon(Icons.shopping_cart),
            ),
            onPressed: () {},
          ),
        ],
      ),
      body: cart.items.isEmpty
          ? Center(child: Text('Cart is empty'))
          : Column(
              children: [
                Expanded(
                  child: ListView.builder(
                    itemCount: cart.items.length,
                    itemBuilder: (context, index) {
                      final item = cart.items[index];
                      return ListTile(
                        title: Text(item.name),
                        subtitle: Text('\$${item.price} x ${item.quantity}'),
                        trailing: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            IconButton(
                              icon: Icon(Icons.remove),
                              onPressed: () {
                                cart.updateQuantity(item.id, item.quantity - 1);
                              },
                            ),
                            Text('${item.quantity}'),
                            IconButton(
                              icon: Icon(Icons.add),
                              onPressed: () {
                                cart.updateQuantity(item.id, item.quantity + 1);
                              },
                            ),
                            IconButton(
                              icon: Icon(Icons.delete),
                              onPressed: () => cart.removeItem(item.id),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                ),
                Container(
                  padding: EdgeInsets.all(16),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        'Total: \$${cart.totalPrice.toStringAsFixed(2)}',
                        style: TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      ElevatedButton(
                        onPressed: () {},
                        child: Text('Checkout'),
                      ),
                    ],
                  ),
                ),
              ],
            ),
    );
  }
}
```

## Riverpod（更现代的状态管理）

Riverpod 是 Provider 的改进版本，提供更好的类型安全和性能。

### 安装 Riverpod

```yaml
# pubspec.yaml
dependencies:
  flutter_riverpod: ^2.5.1
```

### 基本使用

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// 1. 创建 Provider（类似于 React 的 useState 或 useReducer）
final counterProvider = StateNotifierProvider<CounterNotifier, int>((ref) {
  return CounterNotifier();
});

// 2. 创建 Notifier
class CounterNotifier extends StateNotifier<int> {
  CounterNotifier() : super(0);
  
  void increment() => state++;
  void decrement() => state--;
}

// 3. 在应用根部提供 ProviderScope
void main() {
  runApp(
    ProviderScope(
      child: MyApp(),
    ),
  );
}

// 4. 在 Widget 中使用（使用 ConsumerWidget）
class CounterWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final count = ref.watch(counterProvider);
    
    return Column(
      children: [
        Text('Count: $count'),
        ElevatedButton(
          onPressed: () => ref.read(counterProvider.notifier).increment(),
          child: Text('Increment'),
        ),
      ],
    );
  }
}

// 或使用 ConsumerStatefulWidget
class CounterWidget2 extends ConsumerStatefulWidget {
  @override
  ConsumerState<CounterWidget2> createState() => _CounterWidget2State();
}

class _CounterWidget2State extends ConsumerState<CounterWidget2> {
  @override
  Widget build(BuildContext context) {
    final count = ref.watch(counterProvider);
    
    return Text('Count: $count');
  }
}
```

## 其他状态管理方案

### GetX

GetX 是一个轻量级的状态管理库，提供状态管理、路由、依赖注入等功能。

```dart
// 安装: get: ^4.6.6

// 使用 GetX Controller
class CounterController extends GetxController {
  var count = 0.obs;  // 响应式变量
  
  void increment() => count++;
}

// 在 Widget 中使用
class CounterWidget extends StatelessWidget {
  final controller = Get.put(CounterController());
  
  @override
  Widget build(BuildContext context) {
    return Obx(() => Text('Count: ${controller.count.value}'));
  }
}
```

### Bloc/Cubit

Bloc 使用事件驱动的方式管理状态，适合复杂的状态逻辑。

```dart
// 安装: flutter_bloc: ^8.1.3

// 定义状态
class CounterState {
  final int count;
  CounterState(this.count);
}

// 定义事件
class CounterEvent {}

class IncrementEvent extends CounterEvent {}
class DecrementEvent extends CounterEvent {}

// 创建 Bloc
class CounterBloc extends Bloc<CounterEvent, CounterState> {
  CounterBloc() : super(CounterState(0)) {
    on<IncrementEvent>((event, emit) {
      emit(CounterState(state.count + 1));
    });
    on<DecrementEvent>((event, emit) {
      emit(CounterState(state.count - 1));
    });
  }
}

// 使用 Bloc
class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<CounterBloc, CounterState>(
      builder: (context, state) {
        return Column(
          children: [
            Text('Count: ${state.count}'),
            ElevatedButton(
              onPressed: () {
                context.read<CounterBloc>().add(IncrementEvent());
              },
              child: Text('Increment'),
            ),
          ],
        );
      },
    );
  }
}
```

## 状态管理最佳实践

### 1. 选择合适的方案

- **简单应用**：使用 `setState`
- **中小型应用**：使用 `Provider`
- **大型应用**：使用 `Riverpod` 或 `Bloc`

### 2. 状态分层

```dart
// 本地状态：使用 setState
class LocalCounter extends StatefulWidget {
  // ...
}

// 应用状态：使用 Provider/Riverpod
class AppState extends ChangeNotifier {
  // ...
}

// 全局状态：使用 ProviderScope 或 GetX
```

### 3. 避免过度使用全局状态

```dart
// ❌ 不好的做法：所有状态都放在全局
class GlobalState extends ChangeNotifier {
  int counter;
  String username;
  List<Item> items;
  // ... 太多状态
}

// ✅ 好的做法：按功能拆分状态
class CounterModel extends ChangeNotifier { /* ... */ }
class UserModel extends ChangeNotifier { /* ... */ }
class CartModel extends ChangeNotifier { /* ... */ }
```

### 4. 使用 Selector 优化性能

```dart
// Provider 中使用 Selector 只监听部分状态
Selector<CartModel, int>(
  selector: (_, cart) => cart.itemCount,
  builder: (context, itemCount, child) {
    return Text('Items: $itemCount');
  },
)

// Riverpod 中使用 select
final itemCount = ref.watch(cartProvider.select((cart) => cart.itemCount));
```

## 总结

- ✅ `setState` 适用于本地状态管理
- ✅ `Provider` 是官方推荐的状态管理方案
- ✅ `Riverpod` 提供更好的类型安全和性能
- ✅ 根据应用规模选择合适的方案
- ✅ 合理拆分状态，避免过度使用全局状态

下一步学习：[路由和导航](./06-路由和导航.md)

