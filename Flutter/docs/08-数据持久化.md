# 数据持久化

Flutter 提供了多种数据持久化方案，从简单的键值对存储到关系型数据库。本章介绍 Flutter 的数据持久化方式。

## SharedPreferences（键值对存储）

SharedPreferences 用于存储简单的键值对数据，类似于 JavaScript 的 `localStorage`。

### 安装

```yaml
# pubspec.yaml
dependencies:
  shared_preferences: ^2.2.2
```

### 基本使用

```dart
import 'package:shared_preferences/shared_preferences.dart';

// 保存数据
Future<void> saveData() async {
  final prefs = await SharedPreferences.getInstance();
  
  // 保存字符串
  await prefs.setString('username', 'Flutter');
  
  // 保存整数
  await prefs.setInt('age', 25);
  
  // 保存布尔值
  await prefs.setBool('isLoggedIn', true);
  
  // 保存浮点数
  await prefs.setDouble('price', 99.99);
  
  // 保存字符串列表
  await prefs.setStringList('tags', ['flutter', 'dart', 'mobile']);
}

// 读取数据
Future<void> loadData() async {
  final prefs = await SharedPreferences.getInstance();
  
  final username = prefs.getString('username');
  final age = prefs.getInt('age');
  final isLoggedIn = prefs.getBool('isLoggedIn') ?? false;
  final price = prefs.getDouble('price');
  final tags = prefs.getStringList('tags');
  
  print('Username: $username');
  print('Age: $age');
}

// 删除数据
Future<void> deleteData() async {
  final prefs = await SharedPreferences.getInstance();
  await prefs.remove('username');
  // 或清空所有数据
  // await prefs.clear();
}

// 检查键是否存在
Future<bool> checkKey() async {
  final prefs = await SharedPreferences.getInstance();
  return prefs.containsKey('username');
}

// 与 JavaScript localStorage 对比
// JavaScript:
//   localStorage.setItem('username', 'Flutter');
//   const username = localStorage.getItem('username');
//   localStorage.removeItem('username');
// Flutter:
//   await prefs.setString('username', 'Flutter');
//   final username = prefs.getString('username');
//   await prefs.remove('username');
```

### 实际应用示例

```dart
class SettingsService {
  static const String _keyTheme = 'theme';
  static const String _keyLanguage = 'language';
  static const String _keyNotifications = 'notifications';
  
  // 保存主题
  static Future<void> saveTheme(String theme) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_keyTheme, theme);
  }
  
  // 获取主题
  static Future<String> getTheme() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_keyTheme) ?? 'light';
  }
  
  // 保存语言
  static Future<void> saveLanguage(String language) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_keyLanguage, language);
  }
  
  // 获取语言
  static Future<String> getLanguage() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_keyLanguage) ?? 'en';
  }
  
  // 保存通知设置
  static Future<void> saveNotifications(bool enabled) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_keyNotifications, enabled);
  }
  
  // 获取通知设置
  static Future<bool> getNotifications() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool(_keyNotifications) ?? true;
  }
}
```

## SQLite（关系型数据库）

SQLite 用于存储结构化数据，类似于 JavaScript 的 IndexedDB 或 Web SQL。

### 安装 sqflite

```yaml
# pubspec.yaml
dependencies:
  sqflite: ^2.3.0
  path: ^1.8.3
```

### 基本使用

```dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

// 数据库模型
class User {
  final int? id;
  final String name;
  final String email;
  
  User({this.id, required this.name, required this.email});
  
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'email': email,
    };
  }
  
  factory User.fromMap(Map<String, dynamic> map) {
    return User(
      id: map['id'],
      name: map['name'],
      email: map['email'],
    );
  }
}

// 数据库帮助类
class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;
  
  DatabaseHelper._init();
  
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('users.db');
    return _database!;
  }
  
  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);
    
    return await openDatabase(
      path,
      version: 1,
      onCreate: _createDB,
    );
  }
  
  Future<void> _createDB(Database db, int version) async {
    await db.execute('''
      CREATE TABLE users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT NOT NULL
      )
    ''');
  }
  
  // 插入数据
  Future<int> insertUser(User user) async {
    final db = await database;
    return await db.insert('users', user.toMap());
  }
  
  // 查询所有数据
  Future<List<User>> getAllUsers() async {
    final db = await database;
    final maps = await db.query('users');
    return maps.map((map) => User.fromMap(map)).toList();
  }
  
  // 根据 ID 查询
  Future<User?> getUserById(int id) async {
    final db = await database;
    final maps = await db.query(
      'users',
      where: 'id = ?',
      whereArgs: [id],
    );
    if (maps.isNotEmpty) {
      return User.fromMap(maps.first);
    }
    return null;
  }
  
  // 更新数据
  Future<int> updateUser(User user) async {
    final db = await database;
    return await db.update(
      'users',
      user.toMap(),
      where: 'id = ?',
      whereArgs: [user.id],
    );
  }
  
  // 删除数据
  Future<int> deleteUser(int id) async {
    final db = await database;
    return await db.delete(
      'users',
      where: 'id = ?',
      whereArgs: [id],
    );
  }
  
  // 关闭数据库
  Future<void> close() async {
    final db = await database;
    await db.close();
  }
}

// 使用示例
Future<void> example() async {
  final db = DatabaseHelper.instance;
  
  // 插入
  final user = User(name: 'Flutter', email: 'flutter@example.com');
  final id = await db.insertUser(user);
  print('Inserted user with id: $id');
  
  // 查询
  final users = await db.getAllUsers();
  print('Users: $users');
  
  // 更新
  final updatedUser = User(id: id, name: 'Updated', email: 'updated@example.com');
  await db.updateUser(updatedUser);
  
  // 删除
  await db.deleteUser(id);
}
```

### 使用 floor（ORM）

`floor` 提供了类型安全的 SQLite ORM，类似于 JavaScript 的 TypeORM。

```yaml
# pubspec.yaml
dependencies:
  floor: ^1.4.0

dev_dependencies:
  floor_generator: ^1.4.0
  build_runner: ^2.4.7
```

```dart
import 'package:floor/floor.dart';

// 实体类
@Entity(tableName: 'users')
class User {
  @PrimaryKey(autoGenerate: true)
  final int? id;
  final String name;
  final String email;
  
  User({this.id, required this.name, required this.email});
}

// DAO（数据访问对象）
@dao
abstract class UserDao {
  @Query('SELECT * FROM users')
  Future<List<User>> getAllUsers();
  
  @Query('SELECT * FROM users WHERE id = :id')
  Future<User?> getUserById(int id);
  
  @insert
  Future<int> insertUser(User user);
  
  @update
  Future<void> updateUser(User user);
  
  @delete
  Future<void> deleteUser(User user);
}

// 数据库类
@Database(version: 1, entities: [User])
abstract class AppDatabase extends FloorDatabase {
  UserDao get userDao;
}

// 使用
final database = await $FloorAppDatabase.databaseBuilder('app_database.db').build();
final userDao = database.userDao;

final user = User(name: 'Flutter', email: 'flutter@example.com');
await userDao.insertUser(user);
final users = await userDao.getAllUsers();
```

## 文件存储

### 读写文件

```dart
import 'dart:io';
import 'package:path_provider/path_provider.dart';

// 获取文件路径
Future<String> getFilePath(String filename) async {
  final directory = await getApplicationDocumentsDirectory();
  return '${directory.path}/$filename';
}

// 写入文件
Future<void> writeFile(String filename, String content) async {
  final file = File(await getFilePath(filename));
  await file.writeAsString(content);
}

// 读取文件
Future<String> readFile(String filename) async {
  final file = File(await getFilePath(filename));
  return await file.readAsString();
}

// 检查文件是否存在
Future<bool> fileExists(String filename) async {
  final file = File(await getFilePath(filename));
  return await file.exists();
}

// 删除文件
Future<void> deleteFile(String filename) async {
  final file = File(await getFilePath(filename));
  await file.delete();
}

// 使用示例
Future<void> example() async {
  await writeFile('data.txt', 'Hello Flutter');
  final content = await readFile('data.txt');
  print(content);  // Hello Flutter
}
```

### 读取 JSON 文件

```dart
import 'dart:convert';
import 'package:flutter/services.dart';

// 从 assets 读取 JSON
Future<Map<String, dynamic>> loadJsonFromAssets(String path) async {
  final String jsonString = await rootBundle.loadString(path);
  return json.decode(jsonString);
}

// 使用
final data = await loadJsonFromAssets('assets/data.json');
```

## Hive（NoSQL 数据库）

Hive 是一个轻量级的 NoSQL 数据库，性能优异，类似于 JavaScript 的 IndexedDB。

### 安装

```yaml
# pubspec.yaml
dependencies:
  hive: ^2.2.3
  hive_flutter: ^1.1.0

dev_dependencies:
  hive_generator: ^2.0.1
  build_runner: ^2.4.7
```

### 基本使用

```dart
import 'package:hive/hive.dart';
import 'package:hive_flutter/hive_flutter.dart';

// 初始化
Future<void> initHive() async {
  await Hive.initFlutter();
  await Hive.openBox('settings');
}

// 基本操作
Future<void> example() async {
  final box = await Hive.openBox('settings');
  
  // 写入
  await box.put('theme', 'dark');
  await box.put('language', 'zh');
  
  // 读取
  final theme = box.get('theme');
  final language = box.get('language', defaultValue: 'en');
  
  // 删除
  await box.delete('theme');
  
  // 清空
  await box.clear();
}

// 存储对象
@HiveType(typeId: 0)
class User extends HiveObject {
  @HiveField(0)
  String name;
  
  @HiveField(1)
  int age;
  
  User({required this.name, required this.age});
}

// 注册适配器
Future<void> initHive() async {
  await Hive.initFlutter();
  Hive.registerAdapter(UserAdapter());
  await Hive.openBox<User>('users');
}

// 使用
Future<void> example() async {
  final box = await Hive.openBox<User>('users');
  
  final user = User(name: 'Flutter', age: 25);
  await box.put('user1', user);
  
  final retrievedUser = box.get('user1');
  print(retrievedUser?.name);
}
```

## 实际应用示例

### 用户偏好设置管理

```dart
class PreferencesService {
  static const String _keyTheme = 'theme';
  static const String _keyLanguage = 'language';
  static const String _keyNotifications = 'notifications';
  
  static Future<void> init() async {
    // 初始化 SharedPreferences
  }
  
  // 主题管理
  static Future<void> setTheme(String theme) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_keyTheme, theme);
  }
  
  static Future<String> getTheme() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_keyTheme) ?? 'light';
  }
  
  // 语言管理
  static Future<void> setLanguage(String language) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_keyLanguage, language);
  }
  
  static Future<String> getLanguage() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_keyLanguage) ?? 'en';
  }
  
  // 通知设置
  static Future<void> setNotifications(bool enabled) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_keyNotifications, enabled);
  }
  
  static Future<bool> getNotifications() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool(_keyNotifications) ?? true;
  }
}
```

### 本地缓存管理

```dart
class CacheService {
  static const String _keyCachePrefix = 'cache_';
  static const Duration _defaultExpiry = Duration(hours: 24);
  
  // 保存缓存
  static Future<void> setCache(String key, String value, {Duration? expiry}) async {
    final prefs = await SharedPreferences.getInstance();
    final expiryTime = DateTime.now().add(expiry ?? _defaultExpiry);
    await prefs.setString('$_keyCachePrefix$key', value);
    await prefs.setString('$_keyCachePrefix${key}_expiry', expiryTime.toIso8601String());
  }
  
  // 获取缓存
  static Future<String?> getCache(String key) async {
    final prefs = await SharedPreferences.getInstance();
    final expiryStr = prefs.getString('$_keyCachePrefix${key}_expiry');
    if (expiryStr == null) return null;
    
    final expiry = DateTime.parse(expiryStr);
    if (DateTime.now().isAfter(expiry)) {
      // 缓存过期，删除
      await prefs.remove('$_keyCachePrefix$key');
      await prefs.remove('$_keyCachePrefix${key}_expiry');
      return null;
    }
    
    return prefs.getString('$_keyCachePrefix$key');
  }
  
  // 清除缓存
  static Future<void> clearCache(String key) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('$_keyCachePrefix$key');
    await prefs.remove('$_keyCachePrefix${key}_expiry');
  }
}
```

## 总结

- ✅ `SharedPreferences` 适合存储简单的键值对数据
- ✅ `SQLite` 适合存储结构化数据
- ✅ `Hive` 提供高性能的 NoSQL 存储
- ✅ 文件存储适合存储大文件或 JSON 数据
- ✅ 根据数据特点选择合适的存储方案

下一步学习：[动画和交互](./09-动画和交互.md)

