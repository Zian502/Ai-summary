# 函数

函数是组织代码的重要方式，Python 提供了强大的函数功能。

## 函数定义和调用

### 基本语法

```python
# 定义函数
def function_name(parameters):
    """文档字符串（docstring）"""
    # 函数体
    return value

# 调用函数
result = function_name(arguments)
```

### 简单示例

```python
def greet(name):
    """向指定的人打招呼"""
    return f"Hello, {name}!"

# 调用函数
message = greet("Python")
print(message)  # Hello, Python!
```

## 函数参数

### 位置参数（Positional Arguments）

```python
def add(a, b):
    """计算两数之和"""
    return a + b

result = add(3, 5)  # 8
```

### 默认参数（Default Arguments）

```python
def greet(name, greeting="Hello"):
    """打招呼，可以指定问候语"""
    return f"{greeting}, {name}!"

print(greet("Python"))              # Hello, Python!
print(greet("Python", "Hi"))         # Hi, Python!
print(greet("Python", greeting="Hi"))  # Hi, Python!
```

**注意**：默认参数必须是不可变对象，避免使用可变对象（如列表、字典）作为默认值。

```python
# 错误示例
def add_item(item, items=[]):  # 危险！所有调用共享同一个列表
    items.append(item)
    return items

# 正确示例
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items
```

### 关键字参数（Keyword Arguments）

```python
def create_user(name, age, email, city="Unknown"):
    """创建用户信息"""
    return {
        'name': name,
        'age': age,
        'email': email,
        'city': city
    }

# 使用关键字参数（顺序可以改变）
user = create_user(
    email="user@example.com",
    name="Alice",
    age=25,
    city="Beijing"
)
```

### 可变位置参数（*args）

```python
def sum_numbers(*args):
    """计算任意数量数字的和"""
    total = 0
    for num in args:
        total += num
    return total

print(sum_numbers(1, 2, 3))        # 6
print(sum_numbers(1, 2, 3, 4, 5))  # 15

# args 是一个元组
def print_args(*args):
    print(f"args 类型: {type(args)}")  # <class 'tuple'>
    print(f"args 内容: {args}")

print_args(1, 2, 3)  # args 类型: <class 'tuple'>, args 内容: (1, 2, 3)
```

### 可变关键字参数（**kwargs）

```python
def print_info(**kwargs):
    """打印关键字参数"""
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Python", version=3.12, year=2023)
# name: Python
# version: 3.12
# year: 2023

# kwargs 是一个字典
def create_profile(**kwargs):
    return kwargs

profile = create_profile(name="Alice", age=25, city="Beijing")
print(profile)  # {'name': 'Alice', 'age': 25, 'city': 'Beijing'}
```

### 参数组合

```python
def complex_function(pos1, pos2, /, pos_or_kw, *, kw1, kw2):
    """
    参数顺序：
    1. 位置参数（/ 之前）
    2. 位置或关键字参数（/ 和 * 之间）
    3. 关键字参数（* 之后）
    """
    pass

# 调用示例
complex_function(1, 2, 3, kw1=4, kw2=5)      # 正确
complex_function(1, 2, pos_or_kw=3, kw1=4, kw2=5)  # 正确
# complex_function(1, 2, 3, 4, kw2=5)  # 错误：kw1 必须是关键字参数
```

### 与其他语言对比

| 语言 | 默认参数 | 可变参数 | 关键字参数 |
|------|---------|---------|-----------|
| **Python** | `def f(x=1):` | `*args, **kwargs` | 支持 |
| **Java** | 不支持 | `...args` | 不支持 |
| **C++** | `void f(int x=1)` | 模板 | 不支持 |
| **JavaScript** | `function f(x=1)` | `...args` | 支持 |

## 返回值

### 单个返回值

```python
def square(x):
    return x ** 2

result = square(5)  # 25
```

### 多个返回值（实际上是元组）

```python
def divide_and_modulo(a, b):
    """返回商和余数"""
    quotient = a // b
    remainder = a % b
    return quotient, remainder  # 返回元组

q, r = divide_and_modulo(17, 5)  # q=3, r=2
result = divide_and_modulo(17, 5)  # result=(3, 2)
```

### 无返回值（返回 None）

```python
def print_message(msg):
    print(msg)
    # 没有 return 语句，默认返回 None

result = print_message("Hello")
print(result)  # None
```

## Lambda 函数（匿名函数）

```python
# Lambda 函数语法：lambda 参数: 表达式
square = lambda x: x ** 2
print(square(5))  # 25

# 等价于
def square(x):
    return x ** 2

# 常用场景：作为参数传递给其他函数
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))  # [1, 4, 9, 16, 25]

# 排序
students = [('Alice', 25), ('Bob', 20), ('Charlie', 30)]
students.sort(key=lambda x: x[1])  # 按年龄排序
```

## 作用域（Scope）

### 局部作用域和全局作用域

```python
# 全局变量
x = 10

def function():
    # 局部变量
    y = 20
    print(x)  # 可以访问全局变量
    print(y)  # 访问局部变量

function()
# print(y)  # 错误：y 是局部变量，外部无法访问
```

### global 关键字

```python
x = 10

def modify_global():
    global x  # 声明使用全局变量
    x = 20    # 修改全局变量

modify_global()
print(x)  # 20
```

### nonlocal 关键字

```python
def outer():
    x = 10
    
    def inner():
        nonlocal x  # 声明使用外层函数的变量
        x = 20      # 修改外层函数的变量
    
    inner()
    print(x)  # 20

outer()
```

## 函数装饰器（Decorator）

装饰器是 Python 的高级特性，用于修改或增强函数功能。

### 基本装饰器

```python
def my_decorator(func):
    """装饰器函数"""
    def wrapper(*args, **kwargs):
        print("函数执行前")
        result = func(*args, **kwargs)
        print("函数执行后")
        return result
    return wrapper

@my_decorator
def say_hello(name):
    print(f"Hello, {name}!")

say_hello("Python")
# 输出:
# 函数执行前
# Hello, Python!
# 函数执行后
```

### 带参数的装饰器

```python
def repeat(times):
    """装饰器工厂函数"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def greet(name):
    print(f"Hello, {name}!")

greet("Python")
# 输出:
# Hello, Python!
# Hello, Python!
# Hello, Python!
```

### 内置装饰器

```python
# @staticmethod：静态方法
class MyClass:
    @staticmethod
    def static_method():
        print("这是静态方法")

# @classmethod：类方法
class MyClass:
    @classmethod
    def class_method(cls):
        print(f"这是类方法，类名: {cls.__name__}")

# @property：属性装饰器
class Person:
    def __init__(self, name):
        self._name = name
    
    @property
    def name(self):
        return self._name
    
    @name.setter
    def name(self, value):
        self._name = value
```

## 实际应用场景 Demo

### Demo 1: 计算器函数库

```python
#!/usr/bin/env python3
# calculator.py - 计算器函数库

def add(*args):
    """计算多个数字的和"""
    return sum(args)

def multiply(*args):
    """计算多个数字的积"""
    result = 1
    for num in args:
        result *= num
    return result

def power(base, exponent):
    """计算幂"""
    return base ** exponent

def calculate(operation, *args, **kwargs):
    """
    通用计算函数
    
    参数:
        operation: 操作类型（'add', 'multiply', 'power'）
        *args: 位置参数
        **kwargs: 关键字参数（用于 power 操作）
    """
    operations = {
        'add': add,
        'multiply': multiply,
        'power': power
    }
    
    if operation not in operations:
        raise ValueError(f"不支持的操作: {operation}")
    
    func = operations[operation]
    
    if operation == 'power':
        # power 需要两个参数
        if len(args) < 2:
            base = kwargs.get('base', args[0] if args else 0)
            exponent = kwargs.get('exponent', 0)
            return func(base, exponent)
        return func(args[0], args[1])
    else:
        return func(*args)

def main():
    """主函数"""
    print("=" * 60)
    print("计算器函数库演示")
    print("=" * 60)
    
    # 测试加法
    print(f"\n加法: {calculate('add', 1, 2, 3, 4, 5)}")
    
    # 测试乘法
    print(f"乘法: {calculate('multiply', 2, 3, 4)}")
    
    # 测试幂运算
    print(f"幂运算: {calculate('power', 2, 8)}")
    print(f"幂运算（关键字参数）: {calculate('power', base=2, exponent=8)}")
    
    # 使用 lambda 函数创建自定义操作
    custom_op = lambda x, y: x ** 2 + y ** 2
    print(f"\n自定义操作（x²+y²）: {custom_op(3, 4)}")  # 25

if __name__ == "__main__":
    main()
```

### Demo 2: 函数装饰器应用

```python
#!/usr/bin/env python3
# decorators_demo.py - 装饰器应用示例

import time
from functools import wraps

def timing_decorator(func):
    """计时装饰器"""
    @wraps(func)  # 保留原函数的元数据
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} 执行时间: {end_time - start_time:.4f} 秒")
        return result
    return wrapper

def retry_decorator(max_attempts=3):
    """重试装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    print(f"尝试 {attempt + 1} 失败: {e}，重试中...")
            return None
        return wrapper
    return decorator

def cache_decorator(func):
    """简单缓存装饰器"""
    cache = {}
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        # 使用参数作为缓存键
        key = str(args) + str(sorted(kwargs.items()))
        if key in cache:
            print(f"缓存命中: {func.__name__}")
            return cache[key]
        result = func(*args, **kwargs)
        cache[key] = result
        return result
    return wrapper

# 使用装饰器
@timing_decorator
def slow_function(n):
    """模拟耗时操作"""
    time.sleep(0.1)
    return sum(range(n))

@retry_decorator(max_attempts=3)
def unreliable_function():
    """可能失败的函数"""
    import random
    if random.random() < 0.7:
        raise ValueError("随机失败")
    return "成功"

@cache_decorator
def expensive_function(n):
    """昂贵的计算（会被缓存）"""
    print(f"计算 expensive_function({n})")
    return sum(i ** 2 for i in range(n))

def main():
    """主函数"""
    print("=" * 60)
    print("装饰器应用示例")
    print("=" * 60)
    
    # 测试计时装饰器
    print("\n1. 计时装饰器:")
    result = slow_function(1000000)
    print(f"结果: {result}")
    
    # 测试重试装饰器
    print("\n2. 重试装饰器:")
    for _ in range(3):
        try:
            result = unreliable_function()
            print(f"结果: {result}")
            break
        except ValueError as e:
            print(f"最终失败: {e}")
    
    # 测试缓存装饰器
    print("\n3. 缓存装饰器:")
    print(expensive_function(1000))
    print(expensive_function(1000))  # 第二次调用使用缓存
    print(expensive_function(2000))   # 新参数，重新计算

if __name__ == "__main__":
    main()
```

### Demo 3: 高阶函数应用

```python
#!/usr/bin/env python3
# higher_order_functions.py - 高阶函数应用

def apply_operation(numbers, operation):
    """
    对数字列表应用操作
    
    参数:
        numbers: 数字列表
        operation: 操作函数
    """
    return [operation(x) for x in numbers]

def filter_numbers(numbers, predicate):
    """
    过滤数字列表
    
    参数:
        numbers: 数字列表
        predicate: 谓词函数（返回 True/False）
    """
    return [x for x in numbers if predicate(x)]

def reduce_numbers(numbers, reducer, initial=0):
    """
    归约数字列表
    
    参数:
        numbers: 数字列表
        reducer: 归约函数（接受两个参数）
        initial: 初始值
    """
    result = initial
    for num in numbers:
        result = reducer(result, num)
    return result

def main():
    """主函数"""
    numbers = list(range(1, 11))  # [1, 2, 3, ..., 10]
    
    print("=" * 60)
    print("高阶函数应用示例")
    print("=" * 60)
    
    # 应用操作：平方
    squared = apply_operation(numbers, lambda x: x ** 2)
    print(f"\n原数字: {numbers}")
    print(f"平方后: {squared}")
    
    # 过滤：只保留偶数
    evens = filter_numbers(numbers, lambda x: x % 2 == 0)
    print(f"\n偶数: {evens}")
    
    # 过滤：只保留大于 5 的数
    large = filter_numbers(numbers, lambda x: x > 5)
    print(f"大于 5 的数: {large}")
    
    # 归约：求和
    total = reduce_numbers(numbers, lambda x, y: x + y)
    print(f"\n总和: {total}")
    
    # 归约：求积
    product = reduce_numbers(numbers, lambda x, y: x * y, initial=1)
    print(f"乘积: {product}")
    
    # 使用内置函数（更 Pythonic）
    print("\n使用内置函数:")
    print(f"map: {list(map(lambda x: x ** 2, numbers))}")
    print(f"filter: {list(filter(lambda x: x % 2 == 0, numbers))}")
    
    # 使用 functools.reduce
    from functools import reduce
    print(f"reduce: {reduce(lambda x, y: x + y, numbers)}")

if __name__ == "__main__":
    main()
```

## 函数文档字符串（Docstring）

```python
def calculate_area(length, width):
    """
    计算矩形的面积
    
    参数:
        length (float): 矩形的长度
        width (float): 矩形的宽度
    
    返回:
        float: 矩形的面积
    
    示例:
        >>> calculate_area(5, 3)
        15.0
    """
    return length * width

# 查看文档字符串
print(calculate_area.__doc__)
help(calculate_area)
```

## 下一步

完成函数学习后，建议学习：
1. [面向对象编程](./06-面向对象编程.md) - 类、对象、继承、多态
2. [模块和包](./07-模块和包.md) - 模块系统、包管理

