# 高级特性

Python 提供了许多高级特性，使代码更简洁、高效。

## 生成器（Generator）

生成器是一种特殊的迭代器，使用 `yield` 关键字。

### 生成器函数

```python
def countdown(n):
    """生成器函数：倒计时"""
    while n > 0:
        yield n  # 生成值并暂停
        n -= 1

# 使用生成器
for num in countdown(5):
    print(num)  # 5, 4, 3, 2, 1

# 手动迭代
gen = countdown(3)
print(next(gen))  # 3
print(next(gen))  # 2
print(next(gen))  # 1
```

### 生成器表达式

```python
# 生成器表达式（类似列表推导式）
squares = (x**2 for x in range(10))
print(list(squares))  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 内存友好：不需要一次性生成所有值
large_squares = (x**2 for x in range(1000000))
# 只在使用时才计算，不占用大量内存
```

### 实际应用：读取大文件

```python
def read_large_file(filename):
    """逐行读取大文件（内存友好）"""
    with open(filename, 'r') as f:
        for line in f:
            yield line.strip()

# 使用
for line in read_large_file('large_file.txt'):
    process(line)
```

## 迭代器（Iterator）

迭代器是实现了 `__iter__()` 和 `__next__()` 方法的对象。

```python
class CountDown:
    """自定义迭代器"""
    def __init__(self, start):
        self.current = start
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        self.current -= 1
        return self.current + 1

# 使用
for num in CountDown(5):
    print(num)  # 5, 4, 3, 2, 1
```

## 上下文管理器（Context Manager）

上下文管理器用于管理资源的获取和释放。

### with 语句

```python
# 文件操作（自动关闭）
with open('file.txt', 'r') as f:
    content = f.read()
# 文件自动关闭

# 自定义上下文管理器
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        return False  # 不抑制异常

# 使用
with FileManager('file.txt', 'w') as f:
    f.write("Hello")
```

### contextlib 模块

```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    """使用装饰器创建上下文管理器"""
    f = open(filename, mode)
    try:
        yield f
    finally:
        f.close()

# 使用
with file_manager('file.txt', 'w') as f:
    f.write("Hello")
```

## 装饰器进阶

### 带参数的装饰器

```python
def repeat(times):
    """装饰器工厂"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def greet(name):
    print(f"Hello, {name}!")

greet("Python")
```

### 类装饰器

```python
class CountCalls:
    """统计函数调用次数的装饰器"""
    def __init__(self, func):
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"{self.func.__name__} 被调用了 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello():
    print("Hello!")

say_hello()  # say_hello 被调用了 1 次
say_hello()  # say_hello 被调用了 2 次
```

## 实际应用场景 Demo

### Demo 1: 生成器实现斐波那契数列

```python
#!/usr/bin/env python3
# fibonacci_generator.py - 斐波那契生成器

def fibonacci():
    """无限斐波那契生成器"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

def fibonacci_limit(n):
    """有限斐波那契生成器"""
    a, b = 0, 1
    count = 0
    while count < n:
        yield a
        a, b = b, a + b
        count += 1

def main():
    """主函数"""
    print("=" * 60)
    print("斐波那契生成器演示")
    print("=" * 60)
    
    # 生成前 10 个斐波那契数
    print("\n前 10 个斐波那契数:")
    fib_gen = fibonacci_limit(10)
    for num in fib_gen:
        print(num, end=" ")
    print()
    
    # 无限生成器（取前 20 个）
    print("\n使用无限生成器（前 20 个）:")
    fib = fibonacci()
    for _ in range(20):
        print(next(fib), end=" ")
    print()

if __name__ == "__main__":
    main()
```

### Demo 2: 自定义上下文管理器

```python
#!/usr/bin/env python3
# context_manager_demo.py - 上下文管理器演示

import time
from contextlib import contextmanager

class Timer:
    """计时上下文管理器"""
    def __init__(self, name="操作"):
        self.name = name
        self.start_time = None
        self.end_time = None
    
    def __enter__(self):
        self.start_time = time.time()
        print(f"{self.name} 开始...")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end_time = time.time()
        elapsed = self.end_time - self.start_time
        print(f"{self.name} 完成，耗时: {elapsed:.4f} 秒")
        return False

@contextmanager
def suppress_exception(*exceptions):
    """抑制指定异常的上下文管理器"""
    try:
        yield
    except exceptions:
        pass

def main():
    """主函数"""
    print("=" * 60)
    print("上下文管理器演示")
    print("=" * 60)
    
    # 计时器
    with Timer("计算操作"):
        result = sum(i**2 for i in range(1000000))
        print(f"结果: {result}")
    
    # 异常抑制
    print("\n异常抑制演示:")
    with suppress_exception(ValueError, TypeError):
        int("abc")  # 通常会抛出 ValueError，但被抑制了
        print("异常被抑制，程序继续执行")

if __name__ == "__main__":
    main()
```

### Demo 3: 数据管道（使用生成器）

```python
#!/usr/bin/env python3
# data_pipeline.py - 数据管道

def numbers():
    """生成数字"""
    for i in range(1, 11):
        yield i

def square(nums):
    """平方"""
    for num in nums:
        yield num ** 2

def filter_even(nums):
    """过滤偶数"""
    for num in nums:
        if num % 2 == 0:
            yield num

def main():
    """主函数"""
    print("=" * 60)
    print("数据管道演示")
    print("=" * 60)
    
    # 构建管道：数字 -> 平方 -> 过滤偶数
    pipeline = filter_even(square(numbers()))
    
    print("\n处理结果:")
    for result in pipeline:
        print(result, end=" ")
    print()
    
    # 等价于列表推导式
    result_list = [x**2 for x in range(1, 11) if (x**2) % 2 == 0]
    print("\n使用列表推导式:")
    print(result_list)

if __name__ == "__main__":
    main()
```

## 下一步

完成高级特性学习后，建议学习：
1. [并发编程](./11-并发编程.md) - 多线程、多进程、异步编程
2. [标准库常用模块](./12-标准库常用模块.md) - collections、itertools 等

