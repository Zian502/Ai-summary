# 并发编程

Python 提供了多种并发编程方式：多线程、多进程和异步编程。

## 多线程（threading）

### 基本使用

```python
import threading
import time

def worker(name):
    """工作函数"""
    print(f"线程 {name} 开始")
    time.sleep(2)
    print(f"线程 {name} 结束")

# 创建线程
t1 = threading.Thread(target=worker, args=("Thread-1",))
t2 = threading.Thread(target=worker, args=("Thread-2",))

# 启动线程
t1.start()
t2.start()

# 等待线程完成
t1.join()
t2.join()
```

### 线程同步

```python
import threading

# 锁（Lock）
lock = threading.Lock()
counter = 0

def increment():
    global counter
    for _ in range(100000):
        with lock:  # 使用锁保护临界区
            counter += 1

# 信号量（Semaphore）
semaphore = threading.Semaphore(3)  # 最多3个线程同时访问

def access_resource(name):
    with semaphore:
        print(f"{name} 访问资源")
        time.sleep(1)

# 事件（Event）
event = threading.Event()

def wait_for_event():
    print("等待事件...")
    event.wait()
    print("事件已触发")

event.set()  # 触发事件
```

## 多进程（multiprocessing）

```python
import multiprocessing
import time

def worker(name):
    """工作函数"""
    print(f"进程 {name} 开始")
    time.sleep(2)
    print(f"进程 {name} 结束")

if __name__ == "__main__":
    # 创建进程
    p1 = multiprocessing.Process(target=worker, args=("Process-1",))
    p2 = multiprocessing.Process(target=worker, args=("Process-2",))
    
    # 启动进程
    p1.start()
    p2.start()
    
    # 等待进程完成
    p1.join()
    p2.join()
```

### 进程池

```python
from multiprocessing import Pool

def square(x):
    return x ** 2

if __name__ == "__main__":
    with Pool(processes=4) as pool:
        results = pool.map(square, range(10))
    print(results)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

## 异步编程（asyncio）

```python
import asyncio

async def fetch_data(name, delay):
    """异步函数"""
    print(f"开始获取 {name}")
    await asyncio.sleep(delay)
    print(f"完成获取 {name}")
    return f"数据 {name}"

async def main():
    """主异步函数"""
    # 并发执行多个异步任务
    results = await asyncio.gather(
        fetch_data("A", 2),
        fetch_data("B", 1),
        fetch_data("C", 3)
    )
    return results

# 运行
results = asyncio.run(main())
```

## 实际应用场景 Demo

### Demo 1: 多线程下载器

```python
#!/usr/bin/env python3
# downloader.py - 多线程下载器

import threading
import time
import random

class Downloader:
    """下载器类"""
    def __init__(self, max_workers=3):
        self.max_workers = max_workers
        self.semaphore = threading.Semaphore(max_workers)
    
    def download(self, url):
        """模拟下载"""
        with self.semaphore:
            print(f"开始下载: {url}")
            time.sleep(random.uniform(1, 3))  # 模拟下载时间
            print(f"完成下载: {url}")

def main():
    """主函数"""
    urls = [f"http://example.com/file{i}.txt" for i in range(10)]
    downloader = Downloader(max_workers=3)
    
    threads = []
    for url in urls:
        t = threading.Thread(target=downloader.download, args=(url,))
        threads.append(t)
        t.start()
    
    for t in threads:
        t.join()
    
    print("所有下载完成")

if __name__ == "__main__":
    main()
```

### Demo 2: 异步 Web 请求

```python
#!/usr/bin/env python3
# async_requests.py - 异步请求示例

import asyncio
import aiohttp
import time

async def fetch_url(session, url):
    """异步获取 URL"""
    async with session.get(url) as response:
        return await response.text()

async def main():
    """主函数"""
    urls = [
        "https://httpbin.org/delay/1",
        "https://httpbin.org/delay/2",
        "https://httpbin.org/delay/1",
    ]
    
    async with aiohttp.ClientSession() as session:
        start_time = time.time()
        tasks = [fetch_url(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        end_time = time.time()
        
        print(f"总耗时: {end_time - start_time:.2f} 秒")
        print(f"获取了 {len(results)} 个响应")

if __name__ == "__main__":
    asyncio.run(main())
```

## 下一步

完成并发编程学习后，建议学习：
1. [标准库常用模块](./12-标准库常用模块.md) - collections、itertools 等
2. [性能优化和调试](./14-性能优化和调试.md) - 性能分析、调试技巧

