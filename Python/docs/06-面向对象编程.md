# 面向对象编程

Python 支持面向对象编程（OOP），提供了类、对象、继承、多态等特性。

## 类和对象

### 基本语法

```python
# 定义类
class MyClass:
    """类的文档字符串"""
    pass

# 创建对象（实例化）
obj = MyClass()
```

### 类属性和实例属性

```python
class Person:
    # 类属性（所有实例共享）
    species = "Homo sapiens"
    count = 0
    
    def __init__(self, name, age):
        """构造方法（初始化实例）"""
        # 实例属性（每个实例独有）
        self.name = name
        self.age = age
        Person.count += 1  # 修改类属性
    
    def introduce(self):
        """实例方法"""
        return f"我是 {self.name}，{self.age} 岁"

# 创建对象
person1 = Person("Alice", 25)
person2 = Person("Bob", 30)

print(person1.introduce())  # 我是 Alice，25 岁
print(Person.species)      # Homo sapiens
print(Person.count)        # 2
```

### 方法类型

```python
class MyClass:
    # 实例方法：第一个参数是 self
    def instance_method(self):
        return "实例方法"
    
    # 类方法：第一个参数是 cls，使用 @classmethod 装饰器
    @classmethod
    def class_method(cls):
        return f"类方法，类名: {cls.__name__}"
    
    # 静态方法：不需要 self 或 cls，使用 @staticmethod 装饰器
    @staticmethod
    def static_method():
        return "静态方法"

# 调用方法
obj = MyClass()
obj.instance_method()      # 通过实例调用
MyClass.class_method()     # 通过类调用
MyClass.static_method()    # 通过类调用
```

### 与其他语言对比

| 语言 | 类定义 | 构造方法 | 访问控制 |
|------|--------|---------|---------|
| **Python** | `class MyClass:` | `__init__` | 约定（单下划线/双下划线） |
| **Java** | `class MyClass {}` | `MyClass()` | `private`, `protected`, `public` |
| **C++** | `class MyClass {}` | `MyClass()` | `private`, `protected`, `public` |
| **JavaScript** | `class MyClass {}` | `constructor()` | 无（ES6+） |

**Python 特点**：
- 使用 `self` 作为实例方法的第一个参数
- 没有真正的私有属性（使用命名约定）
- 支持动态添加属性和方法

## 特殊方法（Magic Methods）

Python 提供了丰富的特殊方法（双下划线方法），用于自定义类的行为。

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # 字符串表示
    def __str__(self):
        return f"Point({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
    
    # 比较运算符
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
    
    def __lt__(self, other):
        return (self.x ** 2 + self.y ** 2) < (other.x ** 2 + other.y ** 2)
    
    # 算术运算符
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    
    def __mul__(self, scalar):
        return Point(self.x * scalar, self.y * scalar)
    
    # 长度（用于 len() 函数）
    def __len__(self):
        return int((self.x ** 2 + self.y ** 2) ** 0.5)
    
    # 调用（使对象可调用）
    def __call__(self):
        return f"调用点 ({self.x}, {self.y})"

# 使用示例
p1 = Point(3, 4)
p2 = Point(1, 2)

print(p1)              # Point(3, 4)
print(p1 == p2)        # False
print(p1 + p2)         # Point(4, 6)
print(p1 * 2)          # Point(6, 8)
print(len(p1))         # 5
print(p1())            # 调用点 (3, 4)
```

## 继承

### 基本继承

```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return f"{self.name} 发出声音"

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 调用父类构造方法
        self.breed = breed
    
    def speak(self):
        return f"{self.name} 汪汪叫"

class Cat(Animal):
    def speak(self):
        return f"{self.name} 喵喵叫"

# 使用
dog = Dog("旺财", "金毛")
cat = Cat("小花")

print(dog.speak())  # 旺财 汪汪叫
print(cat.speak())  # 小花 喵喵叫
```

### 多重继承

```python
class A:
    def method(self):
        return "A"

class B:
    def method(self):
        return "B"

class C(A, B):
    pass

obj = C()
print(obj.method())  # A（方法解析顺序：C -> A -> B）
print(C.__mro__)     # 查看方法解析顺序
```

### 方法重写

```python
class Parent:
    def method(self):
        return "父类方法"

class Child(Parent):
    def method(self):
        return "子类方法（重写）"
    
    def parent_method(self):
        return super().method()  # 调用父类方法

child = Child()
print(child.method())         # 子类方法（重写）
print(child.parent_method())  # 父类方法
```

## 封装和属性

### 属性访问控制

```python
class BankAccount:
    def __init__(self, balance):
        self._balance = balance      # 受保护属性（约定）
        self.__account_number = 12345  # 私有属性（名称修饰）
    
    # 使用 @property 装饰器创建只读属性
    @property
    def balance(self):
        return self._balance
    
    # 使用 setter 创建可写属性
    @balance.setter
    def balance(self, value):
        if value < 0:
            raise ValueError("余额不能为负数")
        self._balance = value
    
    def get_account_number(self):
        return self.__account_number

account = BankAccount(1000)
print(account.balance)           # 1000（通过属性访问）
account.balance = 2000            # 通过 setter 设置
# account.balance = -100         # 错误：余额不能为负数
```

## 多态

Python 通过"鸭子类型"（Duck Typing）实现多态。

```python
class Duck:
    def quack(self):
        return "鸭子叫：嘎嘎"

class Dog:
    def quack(self):
        return "狗叫：汪汪"

def make_sound(animal):
    """多态函数：接受任何有 quack 方法的对象"""
    return animal.quack()

duck = Duck()
dog = Dog()

print(make_sound(duck))  # 鸭子叫：嘎嘎
print(make_sound(dog))   # 狗叫：汪汪
```

## 抽象基类（ABC）

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    """抽象基类"""
    
    @abstractmethod
    def area(self):
        """抽象方法：必须由子类实现"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """抽象方法：必须由子类实现"""
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14159 * self.radius

# 使用
rect = Rectangle(5, 3)
circle = Circle(4)

print(f"矩形面积: {rect.area()}")      # 15
print(f"圆形面积: {circle.area():.2f}")  # 50.27
```

## 实际应用场景 Demo

### Demo 1: 图书管理系统

```python
#!/usr/bin/env python3
# library_system.py - 图书管理系统

class Book:
    """图书类"""
    total_books = 0  # 类属性：图书总数
    
    def __init__(self, title, author, isbn):
        self.title = title
        self.author = author
        self.isbn = isbn
        self._is_borrowed = False  # 受保护属性
        Book.total_books += 1
    
    def __str__(self):
        return f"《{self.title}》- {self.author}"
    
    def __repr__(self):
        return f"Book('{self.title}', '{self.author}', '{self.isbn}')"
    
    @property
    def is_borrowed(self):
        return self._is_borrowed
    
    def borrow(self):
        """借书"""
        if self._is_borrowed:
            return False
        self._is_borrowed = True
        return True
    
    def return_book(self):
        """还书"""
        if not self._is_borrowed:
            return False
        self._is_borrowed = False
        return True

class Library:
    """图书馆类"""
    def __init__(self, name):
        self.name = name
        self.books = []
    
    def add_book(self, book):
        """添加图书"""
        self.books.append(book)
        return f"已添加图书: {book}"
    
    def find_book(self, title):
        """查找图书"""
        for book in self.books:
            if book.title == title:
                return book
        return None
    
    def list_available_books(self):
        """列出可借阅的图书"""
        return [book for book in self.books if not book.is_borrowed]
    
    def list_borrowed_books(self):
        """列出已借出的图书"""
        return [book for book in self.books if book.is_borrowed]

def main():
    """主函数"""
    # 创建图书馆
    library = Library("市图书馆")
    
    # 添加图书
    books_data = [
        ("Python编程", "Guido van Rossum", "978-1234567890"),
        ("Java编程", "James Gosling", "978-0987654321"),
        ("数据结构", "Donald Knuth", "978-1122334455"),
    ]
    
    for title, author, isbn in books_data:
        book = Book(title, author, isbn)
        library.add_book(book)
    
    print("=" * 60)
    print(f"欢迎来到 {library.name}")
    print("=" * 60)
    
    # 显示所有图书
    print(f"\n图书馆共有 {len(library.books)} 本图书:")
    for book in library.books:
        status = "已借出" if book.is_borrowed else "可借阅"
        print(f"  {book} - {status}")
    
    # 借书
    print("\n借书操作:")
    book = library.find_book("Python编程")
    if book and book.borrow():
        print(f"成功借阅: {book}")
    else:
        print("借阅失败（可能已借出）")
    
    # 显示可借阅图书
    print("\n可借阅的图书:")
    for book in library.list_available_books():
        print(f"  {book}")
    
    print(f"\n图书总数（类属性）: {Book.total_books}")

if __name__ == "__main__":
    main()
```

### Demo 2: 图形类层次结构

```python
#!/usr/bin/env python3
# shapes.py - 图形类层次结构

from abc import ABC, abstractmethod
import math

class Shape(ABC):
    """抽象图形基类"""
    
    @abstractmethod
    def area(self):
        """计算面积"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """计算周长"""
        pass
    
    def __str__(self):
        return f"{self.__class__.__name__}(面积={self.area():.2f}, 周长={self.perimeter():.2f})"

class Rectangle(Shape):
    """矩形类"""
    def __init__(self, width, height):
        if width <= 0 or height <= 0:
            raise ValueError("宽度和高度必须大于0")
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
    
    def __eq__(self, other):
        if not isinstance(other, Rectangle):
            return False
        return self.width == other.width and self.height == other.height

class Circle(Shape):
    """圆形类"""
    def __init__(self, radius):
        if radius <= 0:
            raise ValueError("半径必须大于0")
        self.radius = radius
    
    def area(self):
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        return 2 * math.pi * self.radius
    
    def __eq__(self, other):
        if not isinstance(other, Circle):
            return False
        return self.radius == other.radius

class Triangle(Shape):
    """三角形类"""
    def __init__(self, a, b, c):
        if not (a + b > c and a + c > b and b + c > a):
            raise ValueError("不能构成三角形")
        self.a = a
        self.b = b
        self.c = c
    
    def area(self):
        # 海伦公式
        s = self.perimeter() / 2
        return math.sqrt(s * (s - self.a) * (s - self.b) * (s - self.c))
    
    def perimeter(self):
        return self.a + self.b + self.c

def calculate_total_area(shapes):
    """计算多个图形的总面积"""
    return sum(shape.area() for shape in shapes)

def main():
    """主函数"""
    print("=" * 60)
    print("图形类层次结构演示")
    print("=" * 60)
    
    # 创建各种图形
    shapes = [
        Rectangle(5, 3),
        Circle(4),
        Triangle(3, 4, 5),
        Rectangle(2, 2),
    ]
    
    print("\n图形列表:")
    for shape in shapes:
        print(f"  {shape}")
    
    # 计算总面积
    total_area = calculate_total_area(shapes)
    print(f"\n所有图形的总面积: {total_area:.2f}")
    
    # 多态演示
    print("\n多态演示（所有图形都有 area 方法）:")
    for shape in shapes:
        print(f"  {shape.__class__.__name__} 的面积: {shape.area():.2f}")

if __name__ == "__main__":
    main()
```

### Demo 3: 数据验证装饰器

```python
#!/usr/bin/env python3
# validation.py - 数据验证装饰器

def validate_age(func):
    """验证年龄的装饰器"""
    def wrapper(self, age):
        if not isinstance(age, int):
            raise TypeError("年龄必须是整数")
        if age < 0 or age > 150:
            raise ValueError("年龄必须在 0-150 之间")
        return func(self, age)
    return wrapper

def validate_email(func):
    """验证邮箱的装饰器"""
    def wrapper(self, email):
        if '@' not in email:
            raise ValueError("无效的邮箱地址")
        return func(self, email)
    return wrapper

class User:
    """用户类"""
    def __init__(self, name):
        self.name = name
        self._age = None
        self._email = None
    
    @property
    def age(self):
        return self._age
    
    @age.setter
    @validate_age
    def age(self, value):
        self._age = value
    
    @property
    def email(self):
        return self._email
    
    @email.setter
    @validate_email
    def email(self, value):
        self._email = value
    
    def __str__(self):
        return f"User(name={self.name}, age={self.age}, email={self.email})"

def main():
    """主函数"""
    print("=" * 60)
    print("数据验证演示")
    print("=" * 60)
    
    user = User("Alice")
    
    # 设置有效数据
    try:
        user.age = 25
        user.email = "alice@example.com"
        print(f"\n成功创建用户: {user}")
    except (ValueError, TypeError) as e:
        print(f"错误: {e}")
    
    # 测试无效数据
    print("\n测试无效数据:")
    try:
        user.age = 200  # 无效年龄
    except ValueError as e:
        print(f"年龄验证失败: {e}")
    
    try:
        user.email = "invalid-email"  # 无效邮箱
    except ValueError as e:
        print(f"邮箱验证失败: {e}")

if __name__ == "__main__":
    main()
```

## 下一步

完成面向对象编程学习后，建议学习：
1. [模块和包](./07-模块和包.md) - 模块系统、包管理
2. [异常处理](./08-异常处理.md) - 异常类型和处理

