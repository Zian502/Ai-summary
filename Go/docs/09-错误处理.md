# 错误处理

## Error 接口

Go 使用 `error` 接口表示错误。

```go
type error interface {
    Error() string
}
```

### 创建错误

```go
import "errors"

err := errors.New("发生了错误")
fmt.Println(err.Error())  // 发生了错误
```

### 格式化错误

```go
import "fmt"

err := fmt.Errorf("用户 %s 不存在", username)
```

**与其他语言对比**：
- **C++**: 既可以使用返回值/错误码，也广泛使用异常机制 `try/catch`
- **Rust**: `Result<T, E>` 类型，更安全
- **Java**: `Exception` 类，使用 try-catch

**Go 特点**：
- 错误是值，不是异常
- 显式错误处理
- 没有 try-catch

## 错误处理模式

### 基本模式

```go
result, err := doSomething()
if err != nil {
    // 处理错误
    return err
}
// 使用 result
```

### 多返回值

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("除数不能为0")
    }
    return a / b, nil
}

// 使用
result, err := divide(10, 2)
if err != nil {
    fmt.Printf("错误: %v\n", err)
    return
}
fmt.Printf("结果: %.2f\n", result)
```

### 错误包装

Go 1.13+ 支持错误包装。

```go
import "fmt"

func readFile(filename string) error {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return fmt.Errorf("读取文件失败: %w", err)  // %w 包装错误
    }
    // ...
    return nil
}
```

### 错误检查

```go
import "errors"

if errors.Is(err, os.ErrNotExist) {
    // 文件不存在
}

var pathErr *os.PathError
if errors.As(err, &pathErr) {
    // 是 PathError 类型
    fmt.Println(pathErr.Path)
}
```

## 自定义错误类型

```go
type MyError struct {
    Code    int
    Message string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("错误代码 %d: %s", e.Code, e.Message)
}

func doSomething() error {
    return &MyError{
        Code:    404,
        Message: "资源未找到",
    }
}
```

## 实际应用场景 Demo

### Demo 1: 文件操作错误处理

```go
package main

import (
    "fmt"
    "io/ioutil"
    "os"
)

// readFileContent 读取文件内容（演示错误包装）
func readFileContent(filename string) (string, error) {
    // 打开文件
    file, err := os.Open(filename)
    if err != nil {
        // 使用 %w 包装错误，保留原始错误信息
        return "", fmt.Errorf("打开文件失败: %w", err)
    }
    defer file.Close() // 确保文件关闭
    
    // 读取文件内容
    content, err := ioutil.ReadAll(file)
    if err != nil {
        // 包装错误，添加上下文信息
        return "", fmt.Errorf("读取文件失败: %w", err)
    }
    
    return string(content), nil
}

// writeFileContent 写入文件内容（演示错误包装）
func writeFileContent(filename, content string) error {
    // 创建文件
    file, err := os.Create(filename)
    if err != nil {
        return fmt.Errorf("创建文件失败: %w", err)
    }
    defer file.Close() // 确保文件关闭
    
    // 写入内容
    _, err = file.WriteString(content)
    if err != nil {
        return fmt.Errorf("写入文件失败: %w", err)
    }
    
    return nil
}

func main() {
    // 读取文件
    content, err := readFileContent("test.txt")
    if err != nil {
        fmt.Printf("读取失败: %v\n", err)
        // 可以继续处理或返回
    } else {
        fmt.Printf("文件内容: %s\n", content)
    }
    
    // 写入文件
    err = writeFileContent("output.txt", "Hello, Go!")
    if err != nil {
        fmt.Printf("写入失败: %v\n", err)
    } else {
        fmt.Println("写入成功")
    }
}
```

### Demo 2: 网络请求错误处理

```go
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
    "time"
)

// HTTPError 自定义 HTTP 错误类型
type HTTPError struct {
    StatusCode int    // HTTP 状态码
    URL        string // 请求的 URL
}

// Error 实现 error 接口
func (e *HTTPError) Error() string {
    return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.URL)
}

// fetchURL 获取 URL 内容（演示自定义错误类型）
func fetchURL(url string, timeout time.Duration) ([]byte, error) {
    // 创建带超时的 HTTP 客户端
    client := &http.Client{
        Timeout: timeout,
    }
    
    // 发送 HTTP GET 请求
    resp, err := client.Get(url)
    if err != nil {
        return nil, fmt.Errorf("请求失败: %w", err) // 包装网络错误
    }
    defer resp.Body.Close() // 确保响应体关闭
    
    // 检查 HTTP 状态码
    if resp.StatusCode != http.StatusOK {
        // 返回自定义错误类型
        return nil, &HTTPError{
            StatusCode: resp.StatusCode,
            URL:        url,
        }
    }
    
    // 读取响应体
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("读取响应失败: %w", err)
    }
    
    return body, nil
}

func main() {
    url := "https://api.github.com/users/octocat"
    
    data, err := fetchURL(url, time.Second*5)
    if err != nil {
        if httpErr, ok := err.(*HTTPError); ok {
            fmt.Printf("HTTP 错误: %v\n", httpErr)
        } else {
            fmt.Printf("请求错误: %v\n", err)
        }
        return
    }
    
    fmt.Printf("响应长度: %d 字节\n", len(data))
}
```

### Demo 3: 数据库操作错误处理

```go
package main

import (
    "errors"
    "fmt"
)

// 定义错误变量（使用 errors.New 创建）
// 这样可以进行错误比较：err == ErrNotFound
var (
    ErrNotFound     = errors.New("记录未找到")
    ErrInvalidInput = errors.New("无效输入")
    ErrDuplicateKey = errors.New("重复键")
)

// User 用户结构体
type User struct {
    ID   int    // 用户 ID
    Name string // 用户名称
}

// UserRepository 用户仓库（模拟数据库操作）
type UserRepository struct {
    users map[int]*User // 使用 map 存储用户（key: ID, value: User）
}

// NewUserRepository 创建用户仓库
func NewUserRepository() *UserRepository {
    return &UserRepository{
        users: make(map[int]*User),
    }
}

// Create 创建用户
func (r *UserRepository) Create(user *User) error {
    // 验证输入
    if user.Name == "" {
        return ErrInvalidInput // 返回预定义的错误
    }
    
    // 检查是否已存在
    if _, exists := r.users[user.ID]; exists {
        return ErrDuplicateKey
    }
    
    r.users[user.ID] = user
    return nil
}

// FindByID 根据 ID 查找用户
func (r *UserRepository) FindByID(id int) (*User, error) {
    user, exists := r.users[id]
    if !exists {
        return nil, ErrNotFound // 返回预定义的错误
    }
    return user, nil
}

// Update 更新用户
func (r *UserRepository) Update(user *User) error {
    // 检查用户是否存在
    if _, exists := r.users[user.ID]; !exists {
        return ErrNotFound
    }
    
    // 验证输入
    if user.Name == "" {
        return ErrInvalidInput
    }
    
    r.users[user.ID] = user
    return nil
}

func main() {
    repo := NewUserRepository()
    
    // 创建用户
    user := &User{ID: 1, Name: "Alice"}
    if err := repo.Create(user); err != nil {
        if err == ErrDuplicateKey {
            fmt.Println("用户已存在")
        } else {
            fmt.Printf("创建失败: %v\n", err)
        }
    }
    
    // 查找用户
    found, err := repo.FindByID(1)
    if err != nil {
        if err == ErrNotFound {
            fmt.Println("用户不存在")
        } else {
            fmt.Printf("查找失败: %v\n", err)
        }
    } else {
        fmt.Printf("找到用户: %+v\n", found)
    }
    
    // 查找不存在的用户
    _, err = repo.FindByID(999)
    if errors.Is(err, ErrNotFound) {
        fmt.Println("用户 999 不存在")
    }
}
```

### Demo 4: 错误链和上下文

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

// readConfig 读取配置文件（演示错误链的第一层）
func readConfig() error {
    filename := "config.json"
    
    file, err := os.Open(filename)
    if err != nil {
        // 使用 %w 包装错误，形成错误链
        return fmt.Errorf("打开配置文件失败: %w", err)
    }
    defer file.Close()
    
    // 模拟读取配置
    data := make([]byte, 100)
    _, err = file.Read(data)
    if err != nil {
        // 继续包装错误
        return fmt.Errorf("读取配置内容失败: %w", err)
    }
    
    return nil
}

// validateConfig 验证配置（演示错误链的第二层）
func validateConfig() error {
    err := readConfig()
    if err != nil {
        // 继续包装错误，形成错误链
        return fmt.Errorf("配置验证失败: %w", err)
    }
    return nil
}

// initializeApp 初始化应用（演示错误链的第三层）
func initializeApp() error {
    err := validateConfig()
    if err != nil {
        // 继续包装错误，形成完整的错误链
        return fmt.Errorf("应用初始化失败: %w", err)
    }
    return nil
}

func main() {
    err := initializeApp()
    if err != nil {
        fmt.Printf("错误: %v\n", err)
        fmt.Printf("错误链:\n")
        
        // 检查错误链
        if errors.Is(err, os.ErrNotExist) {
            fmt.Println("  原因: 文件不存在")
        }
        
        // 展开错误链
        for err != nil {
            fmt.Printf("  - %v\n", err)
            err = errors.Unwrap(err)
        }
    }
}
```

### Demo 5: 重试机制

```go
package main

import (
    "errors"
    "fmt"
    "time"
)

// ErrTemporary 临时错误（可以重试的错误）
var ErrTemporary = errors.New("临时错误")

// unreliableOperation 模拟不可靠的操作（随机失败）
func unreliableOperation() error {
    // 模拟随机失败：当前时间戳能被 3 整除时失败
    if time.Now().Unix()%3 == 0 {
        return ErrTemporary
    }
    return nil
}

// retryOperation 带重试机制的操作执行
// operation: 要执行的操作函数
// maxRetries: 最大重试次数
// delay: 每次重试之间的延迟
func retryOperation(operation func() error, maxRetries int, delay time.Duration) error {
    var lastErr error
    
    // 尝试执行操作，最多重试 maxRetries 次
    for i := 0; i < maxRetries; i++ {
        err := operation() // 执行操作
        if err == nil {
            return nil // 成功，返回 nil
        }
        
        lastErr = err
        
        // 使用 errors.Is 检查是否是临时错误（支持错误链检查）
        if !errors.Is(err, ErrTemporary) {
            // 非临时错误，不重试，直接返回
            return fmt.Errorf("非临时错误，停止重试: %w", err)
        }
        
        // 如果不是最后一次尝试，等待后重试
        if i < maxRetries-1 {
            fmt.Printf("重试 %d/%d: %v\n", i+1, maxRetries, err)
            time.Sleep(delay) // 等待指定时间
        }
    }
    
    // 所有重试都失败
    return fmt.Errorf("操作失败，已重试 %d 次: %w", maxRetries, lastErr)
}

func main() {
    err := retryOperation(unreliableOperation, 3, time.Second)
    if err != nil {
        fmt.Printf("最终失败: %v\n", err)
    } else {
        fmt.Println("操作成功")
    }
}
```

### Demo 6: 错误分类和处理

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

// ErrorType 错误类型枚举
type ErrorType int

const (
    ErrorTypeNotFound ErrorType = iota // 资源未找到
    ErrorTypePermission                // 权限不足
    ErrorTypeInvalid                   // 无效操作
    ErrorTypeNetwork                   // 网络错误
)

// AppError 应用错误类型（自定义错误类型，支持错误链）
type AppError struct {
    Type    ErrorType // 错误类型
    Message string    // 错误消息
    Cause   error     // 原始错误（支持错误链）
}

// Error 实现 error 接口
func (e *AppError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Cause)
    }
    return e.Message
}

// Unwrap 实现错误链支持（Go 1.13+）
func (e *AppError) Unwrap() error {
    return e.Cause
}

// handleFileOperation 处理文件操作（演示错误分类）
func handleFileOperation(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        // 根据错误类型分类处理
        if os.IsNotExist(err) {
            // 文件不存在错误
            return &AppError{
                Type:    ErrorTypeNotFound,
                Message: "文件不存在",
                Cause:   err,
            }
        }
        if os.IsPermission(err) {
            // 权限错误
            return &AppError{
                Type:    ErrorTypePermission,
                Message: "权限不足",
                Cause:   err,
            }
        }
        // 其他错误
        return &AppError{
            Type:    ErrorTypeInvalid,
            Message: "文件操作失败",
            Cause:   err,
        }
    }
    defer file.Close()
    
    return nil
}

// handleError 根据错误类型进行不同处理（演示 errors.As 的使用）
func handleError(err error) {
    var appErr *AppError
    // 使用 errors.As 检查错误是否是 AppError 类型（支持错误链检查）
    if errors.As(err, &appErr) {
        // 根据错误类型进行不同处理
        switch appErr.Type {
        case ErrorTypeNotFound:
            fmt.Println("处理: 资源未找到，使用默认配置")
        case ErrorTypePermission:
            fmt.Println("处理: 权限不足，请检查文件权限")
        case ErrorTypeInvalid:
            fmt.Println("处理: 无效操作，跳过")
        case ErrorTypeNetwork:
            fmt.Println("处理: 网络错误，稍后重试")
        default:
            fmt.Printf("处理: 未知错误: %v\n", err)
        }
    } else {
        // 不是 AppError 类型，按其他错误处理
        fmt.Printf("处理: 其他错误: %v\n", err)
    }
}

func main() {
    err := handleFileOperation("nonexistent.txt")
    if err != nil {
        handleError(err)
    }
}
```

### Demo 7: Context 与错误处理

`context` 包用于管理请求的生命周期，包括取消、超时和值传递。结合错误处理，可以实现优雅的超时控制和取消机制。

#### 7.1 超时控制

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// fetchData 模拟数据获取（可能耗时较长）
func fetchData(ctx context.Context) (string, error) {
    // 模拟耗时操作
    select {
    case <-time.After(2 * time.Second):
        return "数据获取成功", nil
    case <-ctx.Done():
        // context 被取消或超时
        return "", fmt.Errorf("操作超时: %w", ctx.Err())
    }
}

func main() {
    // 创建带超时的 context（3 秒超时）
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel() // 确保释放资源
    
    result, err := fetchData(ctx)
    if err != nil {
        // 检查是否是超时错误
        if err == context.DeadlineExceeded {
            fmt.Println("请求超时")
        } else {
            fmt.Printf("错误: %v\n", err)
        }
        return
    }
    
    fmt.Println(result)
}
```

#### 7.2 请求取消

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// processTask 处理任务（可以被取消）
func processTask(ctx context.Context, taskID int) error {
    for i := 0; i < 10; i++ {
        // 检查 context 是否被取消
        select {
        case <-ctx.Done():
            return fmt.Errorf("任务 %d 被取消: %w", taskID, ctx.Err())
        default:
            // 继续执行任务
            fmt.Printf("任务 %d: 步骤 %d\n", taskID, i+1)
            time.Sleep(500 * time.Millisecond)
        }
    }
    return nil
}

func main() {
    // 创建可取消的 context
    ctx, cancel := context.WithCancel(context.Background())
    
    // 启动任务
    go func() {
        err := processTask(ctx, 1)
        if err != nil {
            fmt.Printf("任务执行失败: %v\n", err)
        } else {
            fmt.Println("任务完成")
        }
    }()
    
    // 2 秒后取消任务
    time.Sleep(2 * time.Second)
    cancel()
    
    // 等待一下，让 goroutine 有时间响应取消
    time.Sleep(500 * time.Millisecond)
}
```

#### 7.3 级联取消

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// worker 工作协程（可以被取消）
func worker(ctx context.Context, name string, duration time.Duration) error {
    fmt.Printf("%s 开始工作\n", name)
    
    select {
    case <-time.After(duration):
        fmt.Printf("%s 完成工作\n", name)
        return nil
    case <-ctx.Done():
        fmt.Printf("%s 被取消: %v\n", name, ctx.Err())
        return fmt.Errorf("%s 取消: %w", name, ctx.Err())
    }
}

func main() {
    // 创建父 context（带超时）
    parentCtx, parentCancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer parentCancel()
    
    // 创建子 context（继承父 context 的取消）
    childCtx, childCancel := context.WithCancel(parentCtx)
    defer childCancel()
    
    // 启动多个工作协程
    errChan := make(chan error, 3)
    
    go func() {
        errChan <- worker(parentCtx, "Worker1", 5*time.Second)
    }()
    
    go func() {
        errChan <- worker(parentCtx, "Worker2", 3*time.Second)
    }()
    
    go func() {
        errChan <- worker(childCtx, "Worker3", 4*time.Second)
    }()
    
    // 等待所有工作完成或取消
    for i := 0; i < 3; i++ {
        err := <-errChan
        if err != nil {
            fmt.Printf("错误: %v\n", err)
        }
    }
}
```

#### 7.4 HTTP 请求超时

```go
package main

import (
    "context"
    "fmt"
    "io"
    "net/http"
    "time"
)

// fetchWithTimeout 带超时的 HTTP 请求
func fetchWithTimeout(ctx context.Context, url string) ([]byte, error) {
    // 创建 HTTP 客户端
    client := &http.Client{
        Timeout: 5 * time.Second,
    }
    
    // 创建带 context 的请求
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, fmt.Errorf("创建请求失败: %w", err)
    }
    
    // 发送请求
    resp, err := client.Do(req)
    if err != nil {
        // 检查是否是 context 取消/超时
        if ctx.Err() == context.DeadlineExceeded {
            return nil, fmt.Errorf("请求超时: %w", err)
        }
        if ctx.Err() == context.Canceled {
            return nil, fmt.Errorf("请求被取消: %w", err)
        }
        return nil, fmt.Errorf("请求失败: %w", err)
    }
    defer resp.Body.Close()
    
    // 检查 HTTP 状态码
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("HTTP 错误: %d", resp.StatusCode)
    }
    
    // 读取响应体
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("读取响应失败: %w", err)
    }
    
    return body, nil
}

func main() {
    // 创建带超时的 context（3 秒）
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    url := "https://api.github.com/users/octocat"
    data, err := fetchWithTimeout(ctx, url)
    if err != nil {
        // 检查错误类型
        if err == context.DeadlineExceeded {
            fmt.Println("请求超时，请稍后重试")
        } else if err == context.Canceled {
            fmt.Println("请求被取消")
        } else {
            fmt.Printf("请求失败: %v\n", err)
        }
        return
    }
    
    fmt.Printf("响应长度: %d 字节\n", len(data))
}
```

#### 7.5 数据库操作超时

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "time"
)

// 定义错误
var (
    ErrQueryTimeout = errors.New("查询超时")
    ErrQueryCanceled = errors.New("查询被取消")
)

// Database 模拟数据库
type Database struct{}

// Query 模拟数据库查询（可以被取消）
func (db *Database) Query(ctx context.Context, sql string) ([]string, error) {
    // 模拟查询耗时
    select {
    case <-time.After(2 * time.Second):
        // 查询完成
        return []string{"结果1", "结果2", "结果3"}, nil
    case <-ctx.Done():
        // context 被取消或超时
        if ctx.Err() == context.DeadlineExceeded {
            return nil, fmt.Errorf("%w: %v", ErrQueryTimeout, ctx.Err())
        }
        return nil, fmt.Errorf("%w: %v", ErrQueryCanceled, ctx.Err())
    }
}

// Transaction 模拟事务操作
func (db *Database) Transaction(ctx context.Context, operations []func() error) error {
    for i, op := range operations {
        // 检查 context 是否被取消
        select {
        case <-ctx.Done():
            return fmt.Errorf("事务在第 %d 步被取消: %w", i+1, ctx.Err())
        default:
            // 执行操作
            if err := op(); err != nil {
                return fmt.Errorf("事务在第 %d 步失败: %w", i+1, err)
            }
            time.Sleep(100 * time.Millisecond) // 模拟操作耗时
        }
    }
    return nil
}

func main() {
    db := &Database{}
    
    // 示例 1: 带超时的查询
    ctx1, cancel1 := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel1()
    
    results, err := db.Query(ctx1, "SELECT * FROM users")
    if err != nil {
        if errors.Is(err, ErrQueryTimeout) {
            fmt.Println("查询超时，请增加超时时间或优化查询")
        } else {
            fmt.Printf("查询失败: %v\n", err)
        }
    } else {
        fmt.Printf("查询结果: %v\n", results)
    }
    
    // 示例 2: 事务操作
    ctx2, cancel2 := context.WithTimeout(context.Background(), 500*time.Millisecond)
    defer cancel2()
    
    err = db.Transaction(ctx2, []func() error{
        func() error {
            fmt.Println("执行操作 1")
            return nil
        },
        func() error {
            fmt.Println("执行操作 2")
            return nil
        },
        func() error {
            fmt.Println("执行操作 3")
            return nil
        },
    })
    
    if err != nil {
        fmt.Printf("事务失败: %v\n", err)
    } else {
        fmt.Println("事务成功")
    }
}
```

#### 7.6 Context 值传递与错误处理

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// 定义 context 键类型（避免键冲突）
type contextKey string

const (
    requestIDKey contextKey = "requestID"
    userIDKey    contextKey = "userID"
)

// processRequest 处理请求（从 context 获取值）
func processRequest(ctx context.Context) error {
    // 从 context 获取请求 ID
    requestID, ok := ctx.Value(requestIDKey).(string)
    if !ok {
        return fmt.Errorf("缺少请求 ID")
    }
    
    // 从 context 获取用户 ID
    userID, ok := ctx.Value(userIDKey).(int)
    if !ok {
        return fmt.Errorf("缺少用户 ID")
    }
    
    fmt.Printf("处理请求 [%s] 来自用户 [%d]\n", requestID, userID)
    
    // 模拟处理耗时
    select {
    case <-time.After(1 * time.Second):
        fmt.Printf("请求 [%s] 处理完成\n", requestID)
        return nil
    case <-ctx.Done():
        return fmt.Errorf("请求 [%s] 被取消: %w", requestID, ctx.Err())
    }
}

func main() {
    // 创建带值的 context
    ctx := context.WithValue(context.Background(), requestIDKey, "req-123")
    ctx = context.WithValue(ctx, userIDKey, 1001)
    
    // 添加超时控制
    ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()
    
    err := processRequest(ctx)
    if err != nil {
        fmt.Printf("处理失败: %v\n", err)
    }
}
```

#### Context 错误处理要点

1. **检查 context.Done()**：
   - 在长时间运行的操作中，定期检查 `ctx.Done()`
   - 使用 `select` 语句同时监听操作完成和 context 取消

2. **错误包装**：
   - 使用 `ctx.Err()` 获取 context 的错误原因
   - 使用 `%w` 包装 context 错误，保留错误链

3. **错误类型判断**：
   - `context.DeadlineExceeded`：超时错误
   - `context.Canceled`：取消错误
   - 使用 `errors.Is(err, context.DeadlineExceeded)` 检查

4. **资源清理**：
   - 总是调用 `cancel()` 函数释放资源
   - 使用 `defer cancel()` 确保资源被释放

5. **Context 传递**：
   - 将 context 作为函数的第一个参数
   - 在调用链中传递 context，实现级联取消

## 错误处理最佳实践

1. **错误检查**：
   - 总是检查错误
   - 不要忽略错误（除非有明确理由）

2. **错误信息**：
   - 提供有意义的错误信息
   - 包含上下文信息
   - 使用 `fmt.Errorf` 和 `%w` 包装错误

3. **错误类型**：
   - 使用 `errors.Is` 检查错误值
   - 使用 `errors.As` 检查错误类型
   - 定义错误变量而不是字符串

4. **错误处理位置**：
   - 在调用链的适当位置处理错误
   - 不要过度包装错误
   - 在边界处处理错误（如 main 函数）

5. **避免 panic**：
   - 只在真正不可恢复的情况下使用 panic
   - 使用 `recover` 恢复 panic（谨慎使用）

## 下一步

- [包和模块](./10-包和模块.md) - 学习 Go 的包管理和模块系统

